@{
    ViewData["Title"] = "New Graph";
}
@section styles {
    <style>
        .graph {
            position: relative;
            margin-top: -1rem;
            border: 1px solid rgba(1,1,1,.25);
        }

        .vis-network:focus {
            outline: none;
        }

        #mynetwork {
            border: 1px solid lightgray;
            width: 70%;
            height: 90vh;
            z-index: 1;
        }

        .interface {
            position: absolute;
            right: 0;
            z-index: 2;
            background: rgba(1,1,1, .02);
            width: 30%;
            height: 100%;
            padding: 1rem 0 1rem 1rem;
            margin-bottom: 1rem;
        }

        .button-group {
            position: relative;
        }

            .button-group button {
                font-size: 1rem;
                padding: .5rem 1rem;
                cursor: pointer;
                border: 0;
                margin-bottom: .5rem;
                background: transparent;
                display: inline-block;
            }

                .button-group button:hover {
                    cursor: pointer;
                    color: blue;
                }

        button:focus {
            outline: none;
        }

        .customization-box {
            position: relative;
        }

        .draw-title, .select-title {
            display: inline-block;
            text-align: center;
            width: 5ch;
            opacity: .25;
            padding-left: 1rem;
            margin-right: 1rem;
        }

        .draw-group button {
            background: transparent;
            font-size: 1rem;
        }

        .customization-box {
            margin-bottom: 1rem;
        }

        .custom-title {
            line-height: 1.5;
        }

        .custom-label, .custom-label input, .state-switch {
            font-family: 'GTEestiDisplay-Medium',-apple-system,system-ui,BlinkMacSystemFont,'Segoe UI',Roboto,Oxygen-Sans,Ubuntu,Cantarell,'Helvetica Neue',sans-serif,'Apple Color Emoji','Segoe UI Emoji','Segoe UI Symbol';
        }

        .custom-label {
            display: block;
            margin-bottom: .25rem;
        }

            .custom-label input {
                font-size: 1rem;
                width: 15ch;
                padding: .25rem .25rem;
                border: 1px solid rgba(1,1,1, .25);
            }

        .status {
            position: absolute;
            bottom: 1rem;
            z-index: 2;
            color: #333;
            opacity: .25;
        }

        .pickr {
            display: inline-block;
            height: 100%;
        }

        .selectedButton {
            color: #0026ff;
            font-weight: bold;
        }

        .state-switch {
            display: flex;
            width: 70%;
            position: relative;
            user-select: none;
            -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
            position: relative;
            border: 1px solid #0026ff;
            border-radius: 3px;
            color: #555;
        }

        .state-switch > input {
            display: none;
        }

            .state-switch > input:checked + label {
                color: #efefef;
                font-weight: bold;
            }

            .state-switch > input:nth-of-type(1):checked ~ label:last-of-type:before {
                transform: translateX(calc(0% + 0px));
            }

            .state-switch > input:nth-of-type(2):checked ~ label:last-of-type:before {
                transform: translateX(calc(100% + 0px));
            }

            .states-3 > input:nth-of-type(1):checked ~ label:last-of-type:before {
                transform: translateX(calc(0% + 0px));
            }

            .states-3 > input:nth-of-type(2):checked ~ label:last-of-type:before {
                transform: translateX(calc(100% + 0px));
            }
            .states-3 > input:nth-of-type(3):checked ~ label:last-of-type:before {
                transform: translateX(calc(200% + 0px));
            }


        .state-switch label {
            flex: 1;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: pointer;
        }

            .state-switch label:last-of-type:before {
                content: "";
                display: block;
                max-width: calc(50% - 0px);
                height: 100%;
                margin: 0px;
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                z-index: -1;
                transform: translateX(0);
            }

            .states-3 label:last-of-type:before {
                max-width: calc(33.33333% - 0px);
            }


        .state-switch label {
            padding: .25rem 0;
            transition: color 250ms cubic-bezier(0, 0.95, 0.38, 0.98);
        }

            .state-switch label:before {
                background: #0026ff;
                transition: all 250ms cubic-bezier(0, 0.95, 0.38, 0.98);
            }

            .state-switch label:not(:last-child) {
                border-right: 1px solid #fff;
            }

            .edit-group button {
                display: inline-block;
                max-width: 33.3333%;
            }

            .edit-group svg {
               font-size: .85rem;
            }
    </style>
}


<div class="graph">
    <div class="interface">
        <div class="button-group">
            <div class="draw-group">
                <span class="draw-title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M14.078 7.061l2.861 2.862-10.799 10.798-3.584.723.724-3.585 10.798-10.798zm0-2.829l-12.64 12.64-1.438 7.128 7.127-1.438 12.642-12.64-5.691-5.69zm7.105 4.277l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z" /></svg></span>
                <button v-on:click="changeMode('drawNodes')" v-bind:class='{ selectedButton: (state == "drawNodes") }'>Vertices</button>
                <button v-on:click="changeMode('drawEdges')" v-bind:class='{ selectedButton: (state == "drawEdges") }'>Edges</button>
            </div>
            <div class="select-group">
                <span class="select-title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M13 24v-13.333l10 8.333h-6.156l-3.844 5zm8-20h2v-4h-4v2h2v2zm0 6h2v-4h-2v4zm-4-10h-4v2h4v-2zm4 14.73l2 1.645v-4.375h-2v2.73zm-10-14.73h-4v2h4v-2zm0 20h-4v2h4v-2zm-10-16h2v-2h2v-2h-4v4zm2 2h-2v4h2v-4zm0 6h-2v4h2v-4zm0 6h-2v4h4v-2h-2v-2z" /></svg></span>
                <button v-on:click="changeMode('select')" v-bind:class='{ selectedButton: (state == "select") }'>Single</button>
                <button v-on:click="changeMode('selectMultiple')" v-bind:class='{ selectedButton: (state == "selectMultiple") }'>Multiple</button>
            </div>
            <div class="edit-group">
                <button v-on:click="undo()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M18.885 3.515c-4.617-4.618-12.056-4.676-16.756-.195l-2.129-2.258v7.938h7.484l-2.066-2.191c2.82-2.706 7.297-2.676 10.073.1 4.341 4.341 1.737 12.291-5.491 12.291v4.8c3.708 0 6.614-1.244 8.885-3.515 4.686-4.686 4.686-12.284 0-16.97z" /></svg>Undo</button>
                <button v-on:click="redo()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M5.115 3.515c4.617-4.618 12.056-4.676 16.756-.195l2.129-2.258v7.938h-7.484l2.066-2.191c-2.82-2.706-7.297-2.676-10.073.1-4.341 4.341-1.737 12.291 5.491 12.291v4.8c-3.708 0-6.614-1.244-8.885-3.515-4.686-4.686-4.686-12.284 0-16.97z" /></svg>Redo</button>
                <button v-show="(state =='drawNodes' || state == 'drawEdges') || ((state == 'select' || state == 'selectMultiple') && (showNodeCustomization || showEdgeCustomization))" v-on:click="deleteSelected()"><svg width="24" height="24" xmlns="http://www.w3.org/2000/svg" fill-rule="evenodd" clip-rule="evenodd"><path d="M5.662 23l-5.369-5.365c-.195-.195-.293-.45-.293-.707 0-.256.098-.512.293-.707l14.929-14.928c.195-.194.451-.293.707-.293.255 0 .512.099.707.293l7.071 7.073c.196.195.293.451.293.708 0 .256-.097.511-.293.707l-11.216 11.219h5.514v2h-12.343zm3.657-2l-5.486-5.486-1.419 1.414 4.076 4.072h2.829zm.456-11.429l-4.528 4.528 5.658 5.659 4.527-4.53-5.657-5.657z" /></svg> Delete</button>
            </div>
            <div class="export-group">
                <button v-on:click="pdf()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M16 11h5l-9 10-9-10h5v-11h8v11zm1 11h-10v2h10v-2z" /></svg>PDF</button>
                <button v-on:click="img()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M16 11h5l-9 10-9-10h5v-11h8v11zm1 11h-10v2h10v-2z" /></svg>PNG</button>
                <button v-on:click="save()"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M15.003 3h2.997v5h-2.997v-5zm8.997 1v20h-24v-24h20l4 4zm-19 5h14v-7h-14v7zm16 4h-18v9h18v-9z" /></svg>Save</button>
            </div>
        </div>
        <div class="customization-box" v-show="showNodeCustomization">
            <h2 class="custom-title">{{ (state == "selectMultiple" ? "Vertices" : "Vertex") }}</h2>
            <label class="custom-label"><input type="text" id="node-name" placeholder="Name" /> <span class="color-picker"></span> </label>
            <label class="custom-label"></label>
            <div class="node-font-colors state-switch">
                <input type="radio" v-on:click="changeNodeFontColor('white')" name="node-font-color" value="white" id="white-node-font" checked />
                <label for="white-node-font">
                    White Font
                </label>

                <input type="radio" v-on:click="changeNodeFontColor('black')" name="node-font-color" value="black" id="black-node-font" />
                <label for="black-node-font">
                    Black Font
                </label>
            </div>
        </div>
        <div class="customization-box" v-show="showEdgeCustomization">
            <h2 class="custom-title">{{ (state == "selectMultiple" ? "Edges" : "Edge") }}</h2>
            <label class="custom-label"> <input type="text" id="edge-value" placeholder="Weight" /> <span class="color-picker2"></span></label>
            <div class="edge-font-alignments state-switch states-3">
                <input type="radio" v-on:click="changeEdgeFontAlignment('top')" name="edge-font-alignment" value="top" id="align-top" checked />
                <label for="align-top">
                    Top
                </label>
                <input type="radio" v-on:click="changeEdgeFontAlignment('middle')" name="edge-font-alignment" value="middle" id="align-middle" />
                <label for="align-middle">
                    Middle
                </label>
                <input type="radio" v-on:click="changeEdgeFontAlignment('bottom')" name="edge-font-alignment" value="bottom" id="align-bottom" />
                <label for="align-bottom">
                    Bottom
                </label>
            </div>
            <div class="edge-directions state-switch">
                <input type="radio" v-on:click="changeIfDirected('undirected')" name="edge-direction" value="undirected" id="undirected" checked />
                <label for="undirected">
                    Undirected
                </label>
                <input type="radio" v-on:click="changeIfDirected('directed')" name="edge-direction" value="directed" id="directed" />
                <label for="directed">
                    Directed
                </label>
            </div>
        </div>
    </div>
    <div class="status">
        <h2 v-if="state=='drawNodes' || state=='drawEdges'">
            You're drawing {{state=="drawNodes" ? "nodes" : "edges"}}.
        </h2>
        <h2 v-else>You're in select {{state=="select" ? "" : "multiple"}} mode.</h2>
    </div>
    <div id="mynetwork"></div>
</div>

<div id="save-graph-name-prompt" class="modal" v-bind:style="{ 'display': displaySavePrompt }">
    <div class="modal-content">
        <h2>Enter a name for your graph.</h2>
        <label>Graph Name: <input type="text" id="graph-name" /></label>
    </div>
</div>


@section scripts {
    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script type="text/javascript" src="https://www.gstatic.com/firebasejs/6.6.2/firebase-app.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/firebasejs/6.6.1/firebase-auth.js"></script>
    <script type="text/javascript" src="~/js/vis-network.js"></script>
    <script type="text/javascript" src="~/js/FIREBASE_CONFIG.js"></script>
    <script type="text/javascript" src="~/js/firebase.js"></script>
    <script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.4/jspdf.min.js"></script>
    <script type="text/javascript" src="~/js/pickr.min.js"></script>
    <script type="text/javascript">
        const NODES = [];

        const EDGES = [];

        function getGraphData() {
            let url = window.location.pathname;
            url = url.split('/');
            let token = url[url.length - 1];
            $.ajax({
                type: "GET",
                url: "/api/graphData/" + token,
                cache: false,
                async: false,
                success: function (data) {
                    if (data.redirect !== undefined) {
                        window.location.href = data.redirect_url;
                    }

                    var result = jQuery.parseJSON(data);
                    $.each(result, function (key, value) {
                        $.each(value, function (key2, value) {
                            var argb = (value.Color >>> 0).toString(16);
                            var rgba = '#' + argb.slice(2, 9) + argb[0] + argb[1];
                            if (key === "Vertices") {
                                let nodeFontColor;
                                if(value.FontColor === "white") {
                                    nodeFontColor = "#FFFFFF";
                                } else {
                                    nodeFontColor = "#000000";
                                }
                                NODES.push({ id: value.ID, x: value.XPos, y: value.YPos, color: rgba, name: value.Name, font: { color: nodeFontColor } })
                            } else {
                                EDGES.push({ id: value.DBID, first: value.First, second: value.Second, direction: value.Direction, color: rgba, weight: value.Weight })
                            }
                        });
                    });
                }
            });
            return getVisDataSet();
        }
    </script>
    <script>
        // Snapshot Model

        const ACTION_BATCH = "-1"; // A collection of actions
        const ACTION_ADD_VERTEX = "0";
        const ACTION_ADD_EDGE = "1";

        const ACTION_DELETE_VERTEX = "2";
        const ACTION_DELETE_VERTEX_N_EDGE = "3";
        const ACTION_DELETE_EDGE = "4";

        const ACTION_NODE_RECOLOR = "5";
        const ACTION_NODE_RENAME = "6";
        const ACTION_NODE_FONT_RECOLOR = "7";
        const ACTION_NODE_CHANGE_POS = "8";

        const ACTION_EDGE_RENAME = "9";
        const ACTION_EDGE_RECOLOR = "10";
        const ACTION_EDGE_CHANGE_FONT_ALIGNMENT = "11";
        const ACTION_EDGE_CHANGE_IF_DIRECTED = "12";

        const ACTION_GRAPH_SET_NAME = "13";

        const SNAPSHOT = {
            0: []
        };

        let REDO_STACK = [];
        let CURRENT_SNAPSHOT = 0;

        function clearRedoStack() {
            REDO_STACK = [];
        }

        function startBatchAction() {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_BATCH,
                actions: []
            });
        }

        function moveLastActionToBatch() {
            const lastAction = SNAPSHOT[CURRENT_SNAPSHOT].pop();
            SNAPSHOT[CURRENT_SNAPSHOT][SNAPSHOT[CURRENT_SNAPSHOT].length - 1].actions.push(lastAction);
        }

        function addNodeAction(id_, color_, x_, y_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_ADD_VERTEX,
                id: id_,
                color: color_,
                x: x_,
                y: y_
            });
        }

        function addEdgeAction(id_, isDirected_, from_, to_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_ADD_EDGE,
                id: id_,
                isDirected: isDirected_,
                from: from_,
                to: to_
            });
        }

        function deleteNodeAction(node_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_VERTEX,
                node: node_
            });
        }

        function deleteNodeEdgeAction(node_, edges_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_VERTEX_N_EDGE,
                node: node_,
                edges: edges_
            });
        }

        function deleteEdgeAction(edge_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_EDGE,
                edge: edge_
            });
        }

        function recolorNodeAction(vertexId, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_RECOLOR,
                id: vertexId,
                prevColor: prevColor_,
                color: color_
            });
        }

        function renameNodeAction(vertexId, fontColor_, prevLabel_, label_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_RENAME,
                id: vertexId,
                fontColor: fontColor_,
                prevLabel: prevLabel_,
                label: label_
            });
        }

        function recolorNodeFontAction(vertexId, prevFontColor_, fontColor_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_FONT_RECOLOR,
                id: vertexId,
                prevFontColor: prevFontColor_,
                fontColor: fontColor_
            });
        }

        function repositionNodeAction(vertexId, prevX_, prevY_, x_, y_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_CHANGE_POS,
                id: vertexId,
                prevX: prevX_,
                prevY: prevY_,
                x: x_,
                y: y_

            });
        }

        function renameEdgeAction(id_, from_, to_, alignment_, prevLabel_, label_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_RENAME,
                id: id_,
                from: from_,
                to: to_,
                alignment: alignment_,
                prevLabel: prevLabel_,
                label: label_,
            });
        }

        function recolorEdgeAction(id_, from_, to_, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_RECOLOR,
                id: id_,
                from: from_,
                to: to_,
                prevColor: prevColor_,
                color: color_
            });
        }

        function changeEdgeFontAlignmentAction(id_, from_, to_, prevAlignment_, alignment_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_CHANGE_FONT_ALIGNMENT,
                id: id_,
                from: from_,
                to: to_,
                prevAlignment: prevAlignment_,
                alignment: alignment_
            });
        }

        function changeIfEdgeDirectedAction(id_, from_, to_, prevIfDirected_, ifDirected_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_CHANGE_IF_DIRECTED,
                id: id_,
                from: from_,
                prevIfDirected: prevIfDirected_,
                ifDirected: ifDirected_
            });
        }

        function changeGraphNameAction(graphName_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_GRAPH_SET_NAME,
                graphName: graphName_
            });
        }

        function convertHexToDecimal(color) {
            //#XXXXXX (No alpha means = 0xFF => 255 full alpha)
            console.log("Color : " + color);
            var hexString = "";
            if (color.length === 7) {
                hexString = "FF" + color.slice(1, color.length);
            } else { //#XXXXXXXX (Has an alpha value that is between 0-255)
                hexString = color[7] + color[8] + color.slice(1, 7);
            }
            //return the number as a signed integer
            return parseInt(hexString, 16) >> 0;
        }

        function convertDecimalToHex(value) {
            var argb = (value >>> 0).toString(16);
            var rgba = '#' + argb.slice(2, 9) + argb[0] + argb[1];

            return rgba;
        }

        function getCollapsedSnapshot() {
            const EXPANDED_SNAPSHOT = [];
            const REDUCED_SNAPSHOT = [];
            const stateTree = {};

            // Expand batch actions
            for (action of SNAPSHOT[CURRENT_SNAPSHOT]) {
                if (action.action == ACTION_BATCH) {
                    for (batchedAction of action.actions) {
                        EXPANDED_SNAPSHOT.push(batchedAction);
                    }
                } else {
                    switch (action.action) {
                        case ACTION_NODE_RECOLOR:
                        case ACTION_EDGE_RECOLOR:
                            action.color = convertHexToDecimal(action.color);
                            break;
                    }
                    EXPANDED_SNAPSHOT.push(action);
                }
            }
            
            // Build final state tree
            for (action of EXPANDED_SNAPSHOT) {
                if (action.hasOwnProperty('id')) {
                    if (stateTree.hasOwnProperty(action.id)) {
                        stateTree[action.id][action.action] = action;
                    } else {
                        stateTree[action.id] = {};
                        stateTree[action.id][action.action] = action;
                    }
                } else {
                    REDUCED_SNAPSHOT.push(action);
                    switch (action.action) {
                        case ACTION_DELETE_VERTEX:
                            const nID = action.node.id;
                            if (stateTree[nID].hasOwnProperty(ACTION_ADD_VERTEX)) {
                                // If this was a new node, don't need delete action
                                // to be sent to DB
                                REDUCED_SNAPSHOT.pop();
                            }
                            delete stateTree[nID];
                            break;
                        case ACTION_DELETE_EDGE:
                            let edgeID = action.edge.id;
                            if (stateTree[edgeID].hasOwnProperty(ACTION_ADD_EDGE)) {
                                REDUCED_SNAPSHOT.pop();
                            }
                            delete stateTree[edgeID];
                            break;
                        case ACTION_DELETE_VERTEX_N_EDGE:
                            let nodeID = action.node.id;
                            if (stateTree[nodeID].hasOwnProperty(ACTION_ADD_VERTEX)) {
                                REDUCED_SNAPSHOT.pop();
                            }
                            delete stateTree[nodeID];
                            for (edge of action.edges) {
                                delete stateTree[edge.id];
                            }
                            break;
                    }
                }
            }

            // Collect collapsed snapshot
            for (id in stateTree) {
                for (actionType in stateTree[id]) {
                    REDUCED_SNAPSHOT.push(stateTree[id][actionType]);
                }
            }
            
            return REDUCED_SNAPSHOT;
        }

        function undoLastAction(state) {
            if (SNAPSHOT[CURRENT_SNAPSHOT].length > 0) {
                const lastAction = SNAPSHOT[CURRENT_SNAPSHOT].pop();

                switch (lastAction.action) {
                    case ACTION_BATCH:
                        for (action of lastAction.actions) {
                            SNAPSHOT[CURRENT_SNAPSHOT].push(action);
                            undoLastAction(state);
                            REDO_STACK.pop(); // Only want the batch action to be stored on REDO_STACK
                        }
                        break;
                    case ACTION_ADD_VERTEX:
                        NETWORK.storePositions();
                        vertex = VIS_NODES.get(lastAction.id);
                        lastAction.x = vertex.x;
                        lastAction.y = vertex.y;
                        VIS_NODES.remove(lastAction.id);
                        break;
                    case ACTION_ADD_EDGE:
                        VIS_EDGES.remove(lastAction.id);
                        break;
                    case ACTION_DELETE_EDGE:
                        VIS_EDGES.add(lastAction.edge);
                        break;
                    case ACTION_DELETE_VERTEX:
                        VIS_NODES.add(lastAction.node);
                        break;
                    case ACTION_DELETE_VERTEX_N_EDGE:
                        VIS_NODES.add(lastAction.node);
                        for (edge of lastAction.edges) {
                            VIS_EDGES.add(edge);
                        }
                        break;
                    case ACTION_NODE_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, color: lastAction.prevColor });
                        break;
                    case ACTION_NODE_RENAME:
                        VIS_NODES.update({ id: lastAction.id, label: lastAction.prevLabel, font: { color: lastAction.fontColor } });
                        break;
                    case ACTION_NODE_FONT_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, font: { color: lastAction.prevColor } });
                        break;
                    case ACTION_NODE_CHANGE_POS:
                        VIS_NODES.update({ id: lastAction.id, x: lastAction.prevX, y: lastAction.prevY });
                        break;
                    case ACTION_EDGE_RENAME:
                        VIS_EDGES.update({ id: lastAction.id, label: lastAction.prevLabel, font: { align: lastAction.alignment } });
                        break;
                    case ACTION_EDGE_RECOLOR:
                        VIS_EDGES.update({ id: lastAction.id, color: lastAction.prevColor });
                        break;
                    case ACTION_EDGE_CHANGE_FONT_ALIGNMENT:
                        VIS_EDGES.update({ id: lastAction.id, font: { align: lastAction.prevAlignment } });
                        break;
                    case ACTION_EDGE_CHANGE_IF_DIRECTED:
                        VIS_EDGES.update({ id: lastAction.id, arrows: { to: lastAction.prevIfDirected } });
                        break;
                }

                REDO_STACK.push(lastAction);
                if (state == "drawNodes") {
                    NETWORK.addNodeMode();
                } else if (state == "drawEdges") {
                    NETWORK.addEdgeMode();
                }
            }
        }

        function redoLastAction(state) {
            if (REDO_STACK.length > 0) {
                const lastAction = REDO_STACK.pop();
                switch (lastAction.action) {
                    case ACTION_BATCH:
                        for (action of lastAction.actions) {
                            REDO_STACK.push(action);
                            redoLastAction(state);
                            SNAPSHOT[CURRENT_SNAPSHOT].pop(); // Don't store individual actions back
                        }
                        SNAPSHOT[CURRENT_SNAPSHOT].push(lastAction);
                        break;
                    case ACTION_ADD_VERTEX:
                        VIS_NODES.add({ id: lastAction.id, label: "", color: lastAction.color, x: lastAction.x, y: lastAction.y });
                        addNodeAction(lastAction.id, lastAction.color, lastAction.x, lastAction.y);
                        break;
                    case ACTION_ADD_EDGE:
                        VIS_EDGES.add({ id: lastAction.id, label: "", arrows: { to: lastAction.isDirected }, from: lastAction.from, to: lastAction.to });
                        addEdgeAction(lastAction.id, lastAction.isDirected, lastAction.from, lastAction.to);
                        break;
                    case ACTION_DELETE_EDGE:
                        VIS_EDGES.remove(lastAction.edge.id);
                        deleteEdgeAction(lastAction.edge);
                        break;
                    case ACTION_DELETE_VERTEX:
                        VIS_NODES.remove(lastAction.node.id);
                        deleteNodeAction(lastAction.node);
                        break;
                    case ACTION_DELETE_VERTEX_N_EDGE:
                        VIS_NODES.remove(lastAction.node.id);
                        for (edge of lastAction.edges) {
                            VIS_EDGES.remove(edge.id);
                        }
                        deleteNodeEdgeAction(lastAction.node, lastAction.edges);
                        break;
                    case ACTION_NODE_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, color: lastAction.color });
                        recolorNodeAction(lastAction.id, lastAction.prevColor, lastAction.color);
                        break;
                    case ACTION_NODE_RENAME:
                        VIS_NODES.update({ id: lastAction.id, label: lastAction.label, font: { color: lastAction.fontColor } });
                        renameNodeAction(lastAction.id, lastAction.fontColor, lastAction.prevLabel, lastAction.label);
                        break;
                    case ACTION_NODE_FONT_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, font: { color: lastAction.color } });
                        recolorNodeFontAction(lastAction.id, lastAction.prevColor, lastAction.color);
                        break;
                    case ACTION_NODE_CHANGE_POS:
                        VIS_NODES.update({ id: lastAction.id, x: lastAction.x, y: lastAction.y });
                        repositionNodeAction(lastAction.id, lastAction.prevX, lastAction.prevY, lastAction.x, lastAction.y);
                        break;
                    case ACTION_EDGE_RENAME:
                        VIS_EDGES.update({ id: lastAction.id, label: lastAction.label, font: { align: lastAction.alignment } });
                        renameEdgeAction(lastAction.id, lastAction.from, lastAction.to, lastAction.alignment, lastAction.prevLabel, lastAction.label);
                        break;
                    case ACTION_EDGE_RECOLOR:
                        VIS_EDGES.update({ id: lastAction.id, color: lastAction.color });
                        recolorEdgeAction(lastAction.id, lastAction.from, lastAction.to, lastAction.prevColor, lastAction.color);
                        break;
                    case ACTION_EDGE_CHANGE_FONT_ALIGNMENT:
                        VIS_EDGES.update({ id: lastAction.id, font: { align: lastAction.alignment } });
                        changeEdgeFontAlignmentAction(lastAction.id, lastAction.from, lastAction.to, lastAction.prevAlignment, lastAction.alignemnt);
                        break;
                    case ACTION_EDGE_CHANGE_IF_DIRECTED:
                        VIS_EDGES.update({ id: lastAction.id, arrows: { to: lastAction.ifDirected } });
                        changeIfEdgeDirectedAction(lastAction.id, lastAction.from, lastAction.to, lastAction.prevIfDirected, lastAction.ifDirected);
                        break;
                }
                if (state == "drawNodes") {
                    NETWORK.addNodeMode();
                } else if (state == "drawEdges") {
                    NETWORK.addEdgeMode();
                }
            }
        }</script>
    <script type="text/javascript">
    let NETWORK;
        let VIS_NODES, VIS_EDGES;
        function getVisDataSet() {

            // Convert our DB data to vis data.
            const nodes = [], edges = [];

            for (node of NODES) {
                nodes.push({
                    id: node.id, label: node.name, x: node.x, y: node.y,
                    color: node.color, font: { color: node.font.color }
                });
            }

            for (edge of EDGES) {
                edges.push({
                    from: edge.first, to: edge.second, color: edge.color,
                    arrows: { to: edge.direction === 2, from: edge.direction === 1, enabled: edge.direction !== 0 },
                    label: edge.weight.toString(), font: { align: 'top' }
                });
            }

            VIS_NODES = new vis.DataSet(nodes);
            VIS_EDGES = new vis.DataSet(edges);

            return {
                nodes: VIS_NODES,
                edges: VIS_EDGES
            };
        }

        var app = new Vue({
            el: '#app',
            data: {
                user: false,
                state: "drawNodes",
                nextNodeID: 0,
                showNodeCustomization: true,
                showEdgeCustomization: false,
                currentNodes: [],
                currentEdges: [],
                displaySavePrompt: "none"
            },
            mounted: function () {
                const options = {
                    autoResize: true,
                    height: "100%",
                    width: "100%",
                    interaction: {
                        hover: true
                    },
                    layout: {
                        randomSeed: undefined
                    },
                    nodes: {
                        physics: false,
                        color: {
                            border: '#2B7CE9',
                            background: '#97C2FC',
                            highlight: {
                                border: '#2B7CE9',
                                background: '#D2E5FF'
                            },
                            hover: {
                                border: '#2B7CE9',
                                background: '#D2E5FF'
                            }
                        },
                        font: {
                            color: '#000000'
                        }
                    },
                    physics: {
                        barnesHut: {
                            gravitationalConstant: -10000,
                            centralGravity: 0,
                            springLength: 100,
                            springConstant: 0.04,
                            damping: 0.8,
                            avoidOverlap: 1
                        }
                    },
                    edges: {

                    },
                    manipulation: {
                        enabled: true,
                        addNode: function (data, callback) {
                            data.id = nextNodeID;
                            data.color = pickr.getColor().toHEXA().toString();
                            VIS_NODES.update({ id: data.id, label: "", color: data.color, font: { color: '#FFFFFF' }, x: data.x, y: data.y });
                            nextNodeID++;
                            callback(data);
                            addNodeAction(data.id, data.color, data.x, data.y);
                            clearRedoStack();
                            NETWORK.addNodeMode();
                            var addedNodeID = [data.id];
                            NETWORK.selectNodes(addedNodeID, false);
                            document.getElementById('node-name').value = "";
                            document.getElementById('node-name').focus();
                        },
                        addEdge: function (data, callback) {
                            data.color = pickr2.getColor().toHEXA().toString();
                            if (data.from == data.to && this.state == "drawEdges") {
                                if (confirm("Do you want to connect the node to itself?")) {
                                    callback(data);
                                }
                            }
                            else {
                                callback(data);
                            }

                            var directed = false;
                            if (document.querySelector('input[name="edge-direction"]:checked').value == "directed") {
                                directed = true;
                            }

                            addEdgeAction(data.id, directed, data.from, data.to);
                            clearRedoStack();
                            VIS_EDGES.update({ id: data.id, label: "", color: data.color, font: { color: '#000000' }, arrows: { to: directed }, from: data.from, to: data.to });

                            NETWORK.addEdgeMode();

                            var addedEdgeID = [data.id];
                            NETWORK.selectEdges(addedEdgeID);
                            document.getElementById('edge-value').value = "";
                            document.getElementById('edge-value').focus();
                        },
                        deleteNode: function (data, callback) {
                            const nodeId = data.nodes[0];
                            const node = VIS_NODES.get(nodeId);
                            const connectedEdges = NETWORK.getConnectedEdges(nodeId);
                            if (connectedEdges.length > 0) {
                                var edges = [];
                                for (edgeId of connectedEdges) {
                                    edges.push(VIS_EDGES.get(edgeId));
                                    VIS_EDGES.remove(edgeId);
                                }
                                VIS_NODES.remove(nodeId);
                                deleteNodeEdgeAction(node, edges);
                            }
                            else {
                                VIS_NODES.remove(nodeId);
                                deleteNodeAction(node);
                            }
                            clearRedoStack();
                            callback(data);
                        },
                        deleteEdge: function (data, callback) {
                            const edge = VIS_EDGES.get(data.edges[0]) || false;
                            if (edge) {
                                deleteEdgeAction(edge);
                                VIS_EDGES.remove(edge.id);
                                clearRedoStack();
                                callback(data);
                            }
                        }
                    }
                };

                let url = window.location.pathname;
                url = url.split('/');
                let token = url[url.length - 1];

                $.ajax({
                    type: 'GET',
                    url: "/api/getStartingNodeID/" + token,
                    cache: false,
                    async: false,
                    success: function (data) {
                        nextNodeID = data;
                    }
                });

                NETWORK = new vis.Network(document.getElementById('mynetwork'), getGraphData(), options);
                NETWORK.addNodeMode();
            },
            created: function () {
                // When user logs in, store it in this Vue app's data.
                // Add cookie storing user token.
                firebase.auth().onAuthStateChanged(user => {
                    if (user) {
                        this.user = user;
                        user.getIdToken().then(function (idToken) {
                            document.cookie = "aff_t=" + idToken;
                        });
                    }
                    // Reset user
                    else {
                        this.user = user;
                        document.cookie = "aff_t=; Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                    }
                });
            },
            methods: {
                undo: function (event) {
                    undoLastAction(this.state);
                },
                redo: function (event) {
                    redoLastAction(this.state);
                },
                deleteSelected: function (event) {
                    const nodes_ = NETWORK.getSelectedNodes();
                    let edges_ = NETWORK.getSelectedEdges();

                    let isBatchAction = false;
                    if (nodes_.length > 1 || edges_.length > 1) {
                        isBatchAction = true;
                    } else if (nodes_.length > 0 && edges_.length > 0) {
                        isBatchAction = true;
                    }

                    if (isBatchAction) {
                        startBatchAction();
                    }

                    for (node of nodes_) {
                        NETWORK.manipulation.options.deleteNode({
                            nodes: [node]
                        }, (d) => { });
                        if (isBatchAction) moveLastActionToBatch();
                    }

                    // Reselect edges, in case they were deleted by node deletion
                    edges_ = NETWORK.getSelectedEdges();

                    for (edge of edges_) {
                        NETWORK.manipulation.options.deleteEdge({
                            edges: [edge]
                        }, (d) => { });
                        if (isBatchAction) moveLastActionToBatch();
                    }

                    clearRedoStack();
                    NETWORK.disableEditMode();

                    this.currentNodes = [];
                    this.currentEdges = [];
                },
                changeMode: function (newMode) {
                    if (this.state == newMode) {
                        //clicked on same button, exit mode or do nothing?
                    }
                    else {
                        NETWORK.unselectAll();
                        if (this.state == "select" || this.state == "selectMultiple") {
                            NETWORK.off('click');
                        }
                        this.state = newMode;
                        if (newMode == "drawNodes") {
                            this.showNodeCustomization = true;
                            this.showEdgeCustomization = false;
                            NETWORK.addNodeMode();
                        }
                        else if (newMode == "drawEdges") {
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = true;
                            NETWORK.addEdgeMode();
                        }
                        else if (newMode == "select") {
                            NETWORK.disableEditMode();
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = false;
                            var vue = this;
                            NETWORK.on('click', function (properties) {
                                if (NETWORK.getSelectedNodes().length != 0) {
                                    NETWORK.selectNodes(NETWORK.getSelectedNodes(), false);
                                }

                                //Get the node that we have clicked on
                                var node = properties.nodes;
                                //Get the edge that we have clicked on
                                var edge = properties.edges;

                                //If we hit a node else we hit an edge or nothing
                                if (node.length != 0) {
                                    vue.showNodeCustomization = true;
                                    vue.showEdgeCustomization = false;

                                    var updateNode = VIS_NODES.get(node)[0];

                                    document.getElementById('node-name').value = updateNode.label;

                                    document.getElementById('node-name').focus();

                                    //if (updateNode.font.color === '#FFFFFF') {
                                    //    document.getElementById('node-font-color').value = "#FFFFFF";
                                    //} else {
                                    //    document.getElementById('node-font-color').value = "#000000";
                                    //}

                                    pickr.setColor(updateNode.color);

                                } else if (edge.length != 0) {
                                    vue.showNodeCustomization = false;
                                    vue.showEdgeCustomization = true;

                                    var updateEdge = VIS_EDGES.get(edge)[0];

                                    //Init the label editing
                                    document.getElementById('edge-value').value = updateEdge.label;

                                    document.getElementById('edge-value').focus();

                                    //Set the color to what the current node is!
                                    pickr2.setColor(updateEdge.color);

                                    //Init the Alignment
                                    //if (updateEdge.font.align === 'top') {
                                    //    document.getElementById('edge-font-align').value = "top";
                                    //} else if (updateEdge.font.align === 'middle') {
                                    //    document.getElementById('edge-font-align').value = "middle";
                                    //} else {
                                    //    document.getElementById('edge-font-align').value = "bottom";
                                    //}
                                }
                            });
                        }
                        else if (newMode == "selectMultiple") {
                            NETWORK.disableEditMode();
                            NETWORK.unselectAll();
                            this.currentNodes = NETWORK.getSelectedNodes();
                            this.currentEdges = NETWORK.getSelectedEdges();
                            this.showNodeCustomization = true; // temporary
                            this.showEdgeCustomization = true; // temporary

                            var vue = this;
                            NETWORK.on('click', function () {
                                if (NETWORK.getSelectedNodes().length == 0 && NETWORK.getSelectedEdges().length == 0) {
                                    NETWORK.unselectAll();
                                    vue.currentNodes = [];
                                    vue.currentEdges = [];
                                }
                                else if (NETWORK.getSelectedNodes().length != 0) {
                                    selectedNode = NETWORK.getSelectedNodes()[0];
                                    var index = vue.currentNodes.indexOf(String(selectedNode));
                                    if (index != -1) {
                                        vue.currentNodes.splice(index, 1);
                                    }
                                    else {
                                        vue.currentNodes.push(String(NETWORK.getSelectedNodes()));
                                    }
                                    NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                }
                                else {
                                    selectedEdge = NETWORK.getSelectedEdges()[0];
                                    var index = vue.currentEdges.indexOf(String(selectedEdge));
                                    if (index != -1) {
                                        vue.currentEdges.splice(index, 1);
                                    }
                                    else {
                                        vue.currentEdges.push(String(NETWORK.getSelectedEdges()));
                                    }
                                    NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                }
                            });

                            NETWORK.on('dragEnd', function () {
                                if (NETWORK.getSelectedNodes().length == 1) {
                                    if (vue.currentNodes.length != 1) {
                                        vue.currentNodes = [];
                                        vue.currentEdges = [];
                                        vue.currentNodes.push(String(NETWORK.getSelectedNodes()));
                                        NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                    }
                                    else if (vue.currentNodes.length == 1) {
                                        if (String(NETWORK.getSelectedNodes()[0]) != vue.currentNodes[0]) {
                                            vue.currentNodes = [];
                                            vue.currentEdges = [];
                                            vue.currentNodes.push(String(NETWORK.getSelectedNodes()));
                                            NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                        }
                                    }
                                }
                            });
                        }
                    }
                },
                changeNodeFontColor: function (newFontColor) {
                    if (newFontColor == "white") {
                        newFontColor = "#FFFFFF";
                    }
                    else if (newFontColor == "black") {
                        newFontColor = "#000000";
                    }

                    var editNodeIDS = NETWORK.getSelectedNodes();
                    editNodeIDS.forEach(id => {
                        var editNode = VIS_NODES.get(id);

                        if (editNode.font.color !== newFontColor) {
                            recolorNodeFontAction(editNode.id, editNode.font.color, newFontColor);
                            clearRedoStack();
                            editNode.font.color = newFontColor;
                        }

                        VIS_NODES.update(editNode);
                    });
                },
                changeEdgeFontAlignment: function (newAlignment) {
                    var editEdgeIDS = NETWORK.getSelectedEdges();
                    editEdgeIDS.forEach(id => {
                        var editEdge = VIS_EDGES.get(id);

                        if (editEdge.font.align != newAlignment) {
                            changeEdgeFontAlignmentAction(editEdge.id, editEdge.from, editEdge.to, editEdge.font.align, newAlignment);
                            clearRedoStack();
                            editEdge.font.align = newAlignment;
                        }

                        VIS_EDGES.update(editEdge);
                    });
                },
                changeIfDirected: function (newState) {
                    var directed = false;
                    if (newState == 'directed') {
                        directed = true;
                    }
                    var editEdgeIDS = NETWORK.getSelectedEdges();
                    editEdgeIDS.forEach(id => {
                        var editEdge = VIS_EDGES.get(id);

                        if (editEdge.arrows.to != directed) {
                            changeIfEdgeDirectedAction(editEdge.id, editEdge.from, editEdge.to, editEdge.arrows.to, directed);
                            clearRedoStack();
                            editEdge.arrows.to = directed;
                        }

                        VIS_EDGES.update(editEdge);
                    });
                },
                pdf: function (event) {

                    let url = window.location.pathname;
                    url = url.split('/');
                    let token = url[url.length - 1];

                    html2canvas(document.getElementsByTagName("canvas"), {
                        onrendered: function (canvas) {
                            var imgData = canvas.toDataURL('image/png');
                            var doc = new jsPDF('landscape');
                            doc.addImage(imgData, 'PNG', 0, 0);
                            doc.save(token + '.pdf');
                        }
                    });
                },
                img: function (event) {

                    let url = window.location.pathname;
                    url = url.split('/');
                    let token = url[url.length - 1];

                    html2canvas(document.getElementsByTagName("canvas"), {
                        onrendered: function (canvas) {
                            var imgData = canvas.toDataURL('image/png');
                            app.saveAs(imgData, token + '.png');
                        }
                    });
                },
                saveAs: function (uri, filename) {
                    var link = document.createElement('a');

                    if (typeof link.download === 'string') {

                        link.href = uri;
                        link.download = filename;

                        //Firefox requires the link to be in the body
                        document.body.appendChild(link);

                        //simulate click
                        link.click();

                        //remove the link when done
                        document.body.removeChild(link);

                    } else {

                        window.open(uri);

                    }
                },
                signOut: function (event) {
                    if (this.user) {
                        firebase.auth().signOut().then(function () {
                            // Successfully signed out. This cookie will be set at a early time to expire and delete
                            // ensuring the user is correctly signed out
                            document.cookie = "aff_t=; Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                        }).catch(function (error) {
                            // An error happened.
                        });

                        window.location.href = "/"; // kick thew user to the main page on logout
                    }
                },
                save: function () {
                    this.displaySavePrompt = "block";
                    document.getElementById('graph-name').value = "";
                    setTimeout("document.getElementById('graph-name').focus();", 100);

                    var vue = this;
                    document.getElementById('graph-name').addEventListener("keyup", function (event) {
                        if (event.key == "Enter") {
                            var graphName = document.getElementById('graph-name').value;
                            vue.displaySavePrompt = "none";
                            this.removeEventListener("keyup", arguments.callee, false);

                            //changeGraphNameAction(graphName);
                            
                            const COLLAPSED_SNAPSHOT = getCollapsedSnapshot();

                            if (COLLAPSED_SNAPSHOT.length > 0) {

                                var url = window.location.pathname;
                                url = url.split('/');
                                var token = url[url.length - 1];
                                $.ajax({
                                    type: 'POST',
                                    url: '/api/saveToDB/' + token,
                                    contentType: "application/json",
                                    data: JSON.stringify(COLLAPSED_SNAPSHOT),
                                    headers: {
                                        RequestVerificationToken: $('input:hidden[name="__RequestVerificationToken"]').val()
                                    },
                                    success: function () {
                                        alert('Saved');
                                    },
                                    error: function (xhr, textStatus, errorThrown) {
                                        alert(errorThrown);
                                    }
                                });
                            } else {
                                alert('Saved.');
                            }

                        }
                    });
                }
            }
        });

        const pickr = Pickr.create({
            el: '.color-picker',
            theme: 'nano', // 'classic', 'monolith', or 'nano'

            swatches: [
                'rgba(255, 0, 0, 1)',
                'rgba(255, 127, 0, 1)',
                'rgba(0, 255, 0, 1)',
                'rgba(0, 0, 255, 1)',
                'rgba(75, 0, 130, 1)',
                'rgba(139, 0, 255, 1)',
                'rgba(0, 0, 0, 1)'
            ],

            components: {

                // Main components
                preview: true,
                opacity: true,
                hue: true,

                // Input / output Options
                interaction: {
                    hex: false,
                    rgba: false,
                    hsva: false,
                    input: true,
                    clear: true,
                    save: true
                }
            },

            // Default color
            default: '#000000'
        });

        const pickr2 = Pickr.create({
            el: '.color-picker2',
            theme: 'nano', // 'classic', 'monolith', or 'nano'

            swatches: [
                'rgba(255, 0, 0, 1)',
                'rgba(255, 127, 0, 1)',
                'rgba(0, 255, 0, 1)',
                'rgba(0, 0, 255, 1)',
                'rgba(75, 0, 130, 1)',
                'rgba(139, 0, 255, 1)',
                'rgba(0, 0, 0, 1)'
            ],

            components: {

                // Main components
                preview: true,
                opacity: true,
                hue: true,

                // Input / output Options
                interaction: {
                    hex: false,
                    rgba: false,
                    hsva: false,
                    input: true,
                    clear: true,
                    save: true
                }
            },

            // Default color
            default: '#000000'
        });

        pickr.on('save', (color, instance) => {
            pickr.hide();
            if (color != null) {
                color = color.toHEXA().toString();
                var editNodeIDS = NETWORK.getSelectedNodes();
                editNodeIDS.forEach(id => {
                    var editNode = VIS_NODES.get(id);

                    if (editNode.color !== color) {
                        recolorNodeAction(editNode.id, editNode.color, color);
                        clearRedoStack();
                        editNode.color = color;
                    }

                    VIS_NODES.update(editNode);
                });

                var editEdgeIDS = NETWORK.getSelectedEdges();
                editEdgeIDS.forEach(id => {
                    var editEdge = VIS_EDGES.get(id);

                    if (editEdge.color !== color) {
                        recolorEdgeAction(editEdge.id, editEdge.from, editEdge.to, editEdge.color, color);
                        clearRedoStack();
                        editEdge.color = color;
                    }

                    VIS_EDGES.update(editEdge);
                });

            }
        });

        document.getElementById('node-name').addEventListener("keyup", function (event) {
            if (event.key == "Enter") {
                var newLabel = document.getElementById('node-name').value;

                var editNodeIDS = NETWORK.getSelectedNodes();
                editNodeIDS.forEach(id => {
                    var editNode = VIS_NODES.get(id);

                    if (editNode.label !== newLabel) {
                        editNode.font.color = document.querySelector('input[name="node-font-color"]:checked').value;
                        renameNodeAction(editNode.id, editNode.font.color, editNode.label, newLabel);
                        clearRedoStack();
                        editNode.label = newLabel;
                    }

                    VIS_NODES.update(editNode);
                });
            }
        });

        document.getElementById('edge-value').addEventListener("keyup", function (event) {
            if (event.key == "Enter") {
                var newLabel = document.getElementById('edge-value').value;

                var editEdgeIDS = NETWORK.getSelectedEdges();
                editEdgeIDS.forEach(id => {
                    var editEdge = VIS_EDGES.get(id);

                    var newLabel = document.getElementById('edge-value').value;

                    if (editEdge.label !== newLabel) {
                        editEdge.font.align = document.querySelector('input[name="edge-font-alignment"]:checked').value;
                        renameEdgeAction(editEdge.id, editEdge.from, editEdge.to, editEdge.font.align, editEdge.label, newLabel);
                        clearRedoStack();
                        editEdge.label = newLabel;

                    }

                    VIS_EDGES.update(editEdge);
                });
            }
        });

        var startX, startY;
        //Saves the new position for the nodes
        NETWORK.on('dragStart', function (properties) {
            startX = properties.pointer.canvas.x;
            startY = properties.pointer.canvas.y;
        });

        NETWORK.on('dragEnd', function (properties) {
            var xDifference = properties.pointer.canvas.x - startX;
            var yDifference = properties.pointer.canvas.y - startY;

            var selectedNodes = NETWORK.getSelectedNodes();
            for (var i = 0; i < selectedNodes.length; i++) {
                var nodeId = selectedNodes[i];
                const node = VIS_NODES.get(nodeId);
                repositionNodeAction(nodeId, node.x, node.y, (node.x + xDifference), (node.y + yDifference));
                clearRedoStack();
                VIS_NODES.update({ id: nodeId, x: (node.x + xDifference), y: (node.y + yDifference) });
            }
        });

        NETWORK.fit();
        NETWORK.redraw();</script>
}

@{
    ViewData["Title"] = "New Graph";
}

@section styles {
    <style>
        .graph {
            position: relative;
        }

        #mynetwork {
            border: 1px solid lightgray;
            width: 100%;
            height: 100vh;
            margin: 0 auto;
        }

        .button-group {
            position: absolute;
            left: 0;
            z-index: 2;
            margin-bottom: 1rem;
        }

            .button-group button {
                font-size: .85rem;
                padding: .5rem 1rem;
                cursor: pointer;
                color: #efefef;
                background: #333;
                border: 0;
                margin-right: .25rem;
            }

                .button-group button:hover {
                    cursor: pointer;
                    background: #111;
                }

        .status {
            position: absolute;
            top: 3rem;
            z-index: 2;
            color: #333;
            opacity: .25;
        }

        .pickr {
            display: inline-block;
        }
    </style>
}


<div class="graph">

    <div v-show="showNodeCustomization">
        <h2>Node Customization Options:</h2>
        <label> Label/Weight: <input type="text" id="node-name" /></label>
        <label> Color: <span class="color-picker"></span> </label>
        <br />
        <label> Size: <input type="number" min="1" max="20" id="node-size" /></label>
        <label>
            Font Color:
            <select id="node-font-color">
                <option value="#000000">
                    Black
                </option>
                <option value="#FFFFFF">
                    White
                </option>
            </select>
        </label>
        <br />
        <button v-on:click="saveNodeChanges()"> Save Changes </button>
    </div>
    <div v-show="showEdgeCustomization">
        <h2>Edge Customization Options:</h2>
        <label> Label/Weight: <input type="text" id="edge-value" /></label>
        <label> Color: <span class="color-picker2"></span> </label>
        <br />
        <label>
            Edge Font Align:
            <select id="edge-font-align">
                <option value="top">
                    Top
                </option>
                <option value="middle">
                    Middle
                </option>
                <option value="bottom">
                    Bottom
                </option>
            </select>
        </label>
        <br />
        <button v-on:click="saveEdgeChanges()"> Save Changes </button>
    </div>


    <div class="button-group">
        <button v-on:click="changeMode('drawNodes')">Draw Nodes</button>
        <button v-on:click="changeMode('drawEdges')">Draw Edges</button>
        <button v-on:click="changeMode('delete')">Delete</button>
        <button v-on:click="changeMode('select')">Select</button>
        <button v-on:click="changeMode('selectMultiple')">Select Multiple</button>
        <button v-on:click="undo()">Undo</button>
        <button v-on:click="redo()">Redo</button>
        <button v-on:click="pdf()">Download as Pdf</button>
        <button v-on:click="img()">Download as Png</button>
        <button v-on:click="save()">Save</button>
    </div>
    <div class="status">
        <h2 v-if="state=='delete'">You're deleting.</h2>
        <h2 v-else-if="state=='drawNodes' || state=='drawEdges'">You're drawing {{state=="drawNodes" ? "nodes" : "edges"}}.</h2>
        <h2 v-else>You're in select {{state=="select" ? "" : "multiple"}} mode.</h2>
    </div>
    <div id="mynetwork"></div>
</div>


@section scripts {
    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script type="text/javascript" src="https://www.gstatic.com/firebasejs/6.6.2/firebase-app.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/firebasejs/6.6.1/firebase-auth.js"></script>
    <script type="text/javascript" src="~/js/vis-network.js"></script>
    <script type="text/javascript" src="~/js/FIREBASE_CONFIG.js"></script>
    <script type="text/javascript" src="~/js/firebase.js"></script>
    <script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.4/jspdf.min.js"></script>
    <script type="text/javascript" src="~/js/pickr.min.js"></script>
    <script type="text/javascript">
        const NODES = [];

        const EDGES = [];

        function getGraphData() {
            let url = window.location.pathname;
            url = url.split('/');
            let token = url[url.length - 1];
            $.ajax({
                type: "GET",
                url: "/api/graphData/" + token,
                cache: false,
                async: false,
                success: function (data) {
                    if (data.redirect !== undefined) {
                        window.location.href = data.redirect_url;
                    }

                    //If the api says that nonAuthUser is defined dont bother getting the data from the db
                    if (data.nonAuthUser === undefined) {
                        var result = jQuery.parseJSON(data);
                        $.each(result, function (key, value) {
                            $.each(value, function (key2, value) {
                                var argb = (value.Color >>> 0).toString(16);
                                var rgba = '#' + argb.slice(2, 9) + argb[0] + argb[1];
                                if (key === "Vertices") {
                                    NODES.push({ id: value.ID, x: value.XPos, y: value.YPos, color: rgba, name: value.Name })
                                } else {
                                    EDGES.push({ id: value.DBID, first: value.First, second: value.Second, direction: value.Direction, color: rgba, weight: value.Weight })
                                }
                            });
                        });
                    }
                }
            });

            return getVisDataSet();
        }
    </script>
    <script>
        // Snapshot Model
        const ACTION_ADD_VERTEX = "0";
        const ACTION_ADD_EDGE = "1";

        const ACTION_DELETE_VERTEX = "2";
        const ACTION_DELETE_VERTEX_N_EDGE = "3";
        const ACTION_DELETE_EDGE = "4";

        const ACTION_NODE_RECOLOR = "5";
        const ACTION_NODE_RENAME = "6";
        const ACTION_NODE_CHANGE_POS = "7";

        const ACTION_EDGE_RENAME = "8";
        const ACTION_EDGE_RECOLOR = "9";

        const SNAPSHOT = {
            0: []
        };

        const REDO_STACK = [];
        let CURRENT_SNAPSHOT = 0;

        function addNodeAction(vertexId) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({ action: ACTION_ADD_VERTEX, id: vertexId });
        }

        function addEdgeAction(id_, from_, to_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_ADD_EDGE,
                id: id_,
                from: from_,
                to: to_
            });
        }

        function deleteNodeAction(node_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_VERTEX,
                node: node_
            });
        }

        function deleteNodeEdgeAction(node_, edges_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_VERTEX_N_EDGE,
                node: node_,
                edges: edges_
            });
        }

        function deleteEdgeAction(edge_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_EDGE,
                edge: edge_
            });
        }

        function recolorNodeAction(vertexId, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_RECOLOR,
                id: vertexId,
                prevColor: convertHexToDecimal(prevColor_),
                color: convertHexToDecimal(color_)
            });
        }

        function renameNodeAction(vertexId, prevLabel_, label_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_RENAME,
                id: vertexId,
                prevLabel: prevLabel_,
                label: label_
            });
        }

        function repositionNodeAction(vertexId, prevX_, prevY_, x_, y_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_CHANGE_POS,
                id: vertexId,
                prevX: prevX_,
                prevY: prevY_,
                x: x_,
                y: y_

            });
        }

        function renameEdgeAction(id_, prevLabel_, label_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_RENAME,
                id: id_,
                prevLabel: prevLabel_,
                label: label_,
            });
        }

        function recolorEdgeAction(id_, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_RECOLOR,
                id: id_,
                prevColor: convertHexToDecimal(prevColor_),
                color: convertHexToDecimal(color_)
            });
        }

        function convertHexToDecimal(color) {
            //#XXXXXX (No alpha means = 0xFF => 255 full alpha)
            console.log("Color : " + color);
            var hexString = "";
            if (color.length === 7) {
                hexString = "FF" + color.slice(1, color.length);
            } else { //#XXXXXXXX (Has an alpha value that is between 0-255)
                hexString = color[7] + color[8] + color.slice(1, 7);
            }
            //return the number as a signed integer
            return parseInt(hexString, 16) >> 0;
        }

        function convertDecimalToHex(value) {
            var argb = (value >>> 0).toString(16);
            var rgba = '#' + argb.slice(2, 9) + argb[0] + argb[1];

            return rgba;
        }

        function undoLastAction(state) {
            if (SNAPSHOT[CURRENT_SNAPSHOT].length > 0) {
                const lastAction = SNAPSHOT[CURRENT_SNAPSHOT].pop();

                switch (lastAction.action) {
                    case ACTION_ADD_VERTEX:
                        NETWORK.storePositions();
                        vertex = VIS_NODES.get(lastAction.id);
                        lastAction.x = vertex.x;
                        lastAction.y = vertex.y;
                        VIS_NODES.remove(lastAction.id);
                        break;
                    case ACTION_ADD_EDGE:
                        VIS_EDGES.remove(lastAction.id);
                        break;
                    case ACTION_DELETE_EDGE:
                        VIS_EDGES.add(lastAction.edge);
                        break;
                    case ACTION_DELETE_VERTEX:
                        VIS_NODES.add(lastAction.node);
                        break;
                    case ACTION_DELETE_VERTEX_N_EDGE:
                        VIS_NODES.add(lastAction.node);
                        for (edge of lastAction.edges) {
                            VIS_EDGES.add(edge);
                        }
                        break;
                    case ACTION_NODE_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, color: convertDecimalToHex(lastAction.prevColor) });
                        break;
                    case ACTION_NODE_RENAME:
                        VIS_NODES.update({ id: lastAction.id, label: lastAction.prevLabel });
                        break;
                    case ACTION_NODE_CHANGE_POS:
                        VIS_NODES.update({ id: lastAction.id, x: lastAction.prevX, y: lastAction.prevY });
                        break;
                    case ACTION_EDGE_RENAME:
                        VIS_EDGES.update({ id: lastAction.id, label: lastAction.prevLabel });
                        break;
                    case ACTION_EDGE_RECOLOR:
                        VIS_EDGES.update({ id: lastAction.id, color: convertDecimalToHex(lastAction.prevColor) });
                        break;
                }

                REDO_STACK.push(lastAction);
                if (state == "drawNodes") {
                    NETWORK.addNodeMode();
                } else if (state == "drawEdges") {
                    NETWORK.addEdgeMode();
                }
            }
        }

        function redoLastAction(state) {
            if (REDO_STACK.length > 0) {
                const lastAction = REDO_STACK.pop();
                switch (lastAction.action) {
                    case ACTION_ADD_VERTEX:
                        VIS_NODES.add({ id: lastAction.id, label: "", x: lastAction.x, y: lastAction.y });
                        addNodeAction(lastAction.id);
                        break;
                    case ACTION_ADD_EDGE:
                        VIS_EDGES.add({ id: lastAction.id, label: "", from: lastAction.from, to: lastAction.to });
                        addEdgeAction(lastAction.id, lastAction.from, lastAction.to);
                        break;
                    case ACTION_DELETE_EDGE:
                        VIS_EDGES.remove(lastAction.edge.id);
                        deleteEdgeAction(lastAction.edge);
                        break;
                    case ACTION_DELETE_VERTEX:
                        VIS_NODES.remove(lastAction.node.id);
                        deleteNodeAction(lastAction.node);
                        break;
                    case ACTION_DELETE_VERTEX_N_EDGE:
                        VIS_NODES.remove(lastAction.node.id);
                        deleteNodeEdgeAction(lastAction.node, lastAction.edges);
                        break;
                    case ACTION_NODE_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, color: convertDecimalToHex(lastAction.color) });
                        recolorNodeAction(lastAction.id, convertDecimalToHex(lastAction.prevColor), convertDecimalToHex(lastAction.color));
                        break;
                    case ACTION_NODE_RENAME:
                        VIS_NODES.update({ id: lastAction.id, label: lastAction.label });
                        renameNodeAction(lastAction.id, lastAction.prevLabel, lastAction.label);
                        break;
                    case ACTION_NODE_CHANGE_POS:
                        VIS_NODES.update({ id: lastAction.id, x: lastAction.x, y: lastAction.y });
                        repositionNodeAction(lastAction.id, lastAction.prevX, lastAction.prevY, lastAction.x, lastAction.y);
                        break;
                    case ACTION_EDGE_RENAME:
                        VIS_EDGES.update({ id: lastAction.id, label: lastAction.label });
                        renameEdgeAction(lastAction.id, lastAction.prevLabel, lastAction.label);
                        break;
                    case ACTION_EDGE_RECOLOR:
                        VIS_EDGES.update({ id: lastAction.id, color: convertDecimalToHex(lastAction.color) });
                        recolorEdgeAction(lastAction.id, convertDecimalToHex(lastAction.prevColor), convertDecimalToHex(lastAction.color));
                        break;
                }
                if (state == "drawNodes") {
                    NETWORK.addNodeMode();
                } else if (state == "drawEdges") {
                    NETWORK.addEdgeMode();
                }
            }
        }</script>
    <script type="text/javascript">let NETWORK;
        let VIS_NODES, VIS_EDGES;
        function getVisDataSet() {

            // Convert our DB data to vis data.
            const nodes = [], edges = [];

            for (node of NODES) {
                nodes.push({
                    id: node.id, label: node.name, x: node.x, y: node.y,
                    color: node.color, font: { color: '#FFFFFF' }
                });
            }

            for (edge of EDGES) {
                edges.push({
                    from: edge.first, to: edge.second, color: edge.color,
                    arrows: { to: edge.direction === 2, from: edge.direction === 1, enabled: edge.direction !== 0 },
                    label: edge.weight.toString(), font: { align: 'top' }
                });
            }

            VIS_NODES = new vis.DataSet(nodes);
            VIS_EDGES = new vis.DataSet(edges);

            return {
                nodes: VIS_NODES,
                edges: VIS_EDGES
            };
        }

        var app = new Vue({
            el: '#app',
            data: {
                user: false,
                state: "drawNodes",
                nextNodeID: 0,
                showNodeCustomization: true,
                showEdgeCustomization: false,
                editNode: null,
                editEdge: null
            },
            mounted: function () {
                const options = {
                    autoResize: true,
                    height: "100%",
                    width: "100%",
                    interaction: { hover: true },
                    layout: {
                        randomSeed: undefined
                    },
                    nodes: {
                        physics: false,
                        color: {
                            border: '#2B7CE9',
                            background: '#97C2FC',
                            highlight: {
                                border: '#2B7CE9',
                                background: '#D2E5FF'
                            },
                            hover: {
                                border: '#2B7CE9',
                                background: '#D2E5FF'
                            }
                        },
                        font: {
                            color: '#000000'
                        }
                    },
                    physics: {
                        barnesHut: {
                            gravitationalConstant: 0,
                            centralGravity: 0,
                            springConstant: 0,
                        }
                    },
                    edges: {
                        smooth: false
                    },
                    manipulation: {
                        enabled: true,
                        addNode: function (data, callback) {
                            data.id = nextNodeID;
                            data.color = pickr.getColor().toHEXA().toString();
                            VIS_NODES.update({ id: data.id, label: "", color: data.color, font: { color: '#FFFFFF' }, x: data.x, y: data.y });
                            nextNodeID++;
                            callback(data);
                            addNodeAction(data.id);
                            NETWORK.addNodeMode();
                            var addedNodeID = [data.id];
                            NETWORK.selectNodes(addedNodeID, false);
                        },
                        addEdge: function (data, callback) {
                            data.color = pickr2.getColor().toHEXA().toString();
                            if (data.from == data.to && this.state == "drawEdges") {
                                if (confirm("Do you want to connect the node to itself?")) {
                                    callback(data);
                                    addEdgeAction(data.id, data.from, data.to);
                                }
                            }
                            else {
                                callback(data);
                                addEdgeAction(data.id, data.from, data.to);
                            }

                            VIS_EDGES.update({ id: data.id, label: "", color: data.color, font: { color: '#000000' }, from: data.from, to: data.to });
                            NETWORK.addEdgeMode();

                            var addedEdgeID = [data.id];
                            NETWORK.selectEdges(addedEdgeID);
                        },
                        deleteNode: function (data, callback) {
                            const nodeId = data.nodes[0];
                            const node = VIS_NODES.get(nodeId);
                            if (data.edges.length > 0) {
                                const connectedEdges = NETWORK.getConnectedEdges(nodeId);
                                var edges = [];
                                for (edgeId of connectedEdges) {
                                    edges.push(VIS_EDGES.get(edgeId));
                                }
                                deleteNodeEdgeAction(node, edges);
                            }
                            else {
                                deleteNodeAction(node);
                            }
                            callback(data);
                        },
                        deleteEdge: function (data, callback) {
                            deleteEdgeAction(VIS_EDGES.get(data.edges[0]));
                            callback(data);
                        }
                    }
                };

                NETWORK = new vis.Network(document.getElementById('mynetwork'), getGraphData(), options);
                nextNodeID = VIS_NODES.length;
                NETWORK.addNodeMode();
            },
            created: function () {
                // When user logs in, store it in this Vue app's data.
                // Add cookie storing user token.
                firebase.auth().onAuthStateChanged(user => {
                    if (user) {
                        this.user = user;
                        user.getIdToken().then(function (idToken) {
                            document.cookie = "aff_t=" + idToken;
                        });
                    }
                    // Reset user
                    else {
                        this.user = user;
                        document.cookie = "aff_t=";
                        console.log("signed out");
                    }
                });
            },
            methods: {
                undo: function (event) {
                    undoLastAction(this.state);
                },
                redo: function (event) {
                    redoLastAction(this.state);
                },
                saveNodeChanges: function () {
                    var editNodeIDS = NETWORK.getSelectedNodes();
                    editNodeIDS.forEach(id => {
                        this.editNode = VIS_NODES.get(id);

                        var newLabel = document.getElementById('node-name').value;

                        if (this.editNode.label !== newLabel) {
                            renameNodeAction(this.editNode.id, this.editNode.label, newLabel);
                            this.editNode.label = newLabel;
                        }

                        var newColor = pickr.getColor().toHEXA().toString();
                        if (this.editNode.color !== newColor) {
                            recolorNodeAction(this.editNode.id, this.editNode.color, newColor);
                            this.editNode.color = newColor;
                        }

                        this.editNode.font.color = document.getElementById('node-font-color').value;

                        VIS_NODES.update(this.editNode);
                    });
                },
                saveEdgeChanges: function () {
                    var editEdgeIDS = NETWORK.getSelectedEdges();
                    editEdgeIDS.forEach(id => {
                        this.editEdge = VIS_EDGES.get(id);

                        var newLabel = document.getElementById('edge-value').value;

                        if (this.editEdge.label !== newLabel) {
                            renameEdgeAction(this.editEdge.id, this.editEdge.label, newLabel);
                            this.editEdge.label = newLabel;
                        }

                        var newColor = pickr2.getColor().toHEXA().toString();

                        if (this.editEdge.color !== newColor) {
                            recolorEdgeAction(this.editEdge.id, this.editEdge.color, newColor);
                            this.editEdge.color = newColor;
                        }

                        this.editEdge.font.align = document.getElementById('edge-font-align').value;
                        // ADD ACTION FOR FONT ALIGN

                        VIS_EDGES.update(this.editEdge);
                    });
                },
                save: function () {
                    console.log(JSON.stringify(SNAPSHOT));
                    var url = window.location.pathname;
                    url = url.split('/');
                    var token = url[url.length - 1];
                    $.ajax({
                        type: 'POST',
                        url: '/api/saveToDB/' + token,
                        contentType: "application/json",
                        data: JSON.stringify(SNAPSHOT),
                        headers: {
                            RequestVerificationToken: $('input:hidden[name="__RequestVerificationToken"]').val()
                        },
                        success: function () {
                            alert('Saved');
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            alert(errorThrown);
                        }
                    });
                },
                changeMode: function (newMode) {
                    if (this.state == newMode) {
                        //clicked on same button, exit mode or do nothing?
                    }
                    else {
                        NETWORK.unselectAll();
                        if (this.state == "delete" || this.state == "select" || this.state == "selectMultiple") {
                            NETWORK.off('click');
                        }
                        this.state = newMode;
                        if (newMode == "drawNodes") {
                            this.showNodeCustomization = true;
                            this.showEdgeCustomization = false;
                            NETWORK.addNodeMode();
                        }
                        else if (newMode == "drawEdges") {
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = true;
                            NETWORK.addEdgeMode();
                        }
                        else if (newMode == "delete") {
                            NETWORK.disableEditMode();
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = false;
                            NETWORK.on('click', function () {
                                NETWORK.deleteSelected();
                            });
                        }
                        else if (newMode == "select") {
                            NETWORK.disableEditMode();
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = false;
                            var vue = this;
                            NETWORK.on('click', function (properties) {
                                if (NETWORK.getSelectedNodes().length != 0) {
                                    NETWORK.selectNodes(NETWORK.getSelectedNodes(), false);
                                }

                                //Get the node that we have clicked on
                                var node = properties.nodes;
                                //Get the edge that we have clicked on
                                var edge = properties.edges;

                                //If we hit a node else we hit an edge or nothing
                                if (node.length != 0) {
                                    vue.showNodeCustomization = true;
                                    vue.showEdgeCustomization = false;

                                    var updateNode = VIS_NODES.get(node)[0];

                                    vue.editNode = updateNode;

                                    document.getElementById('node-name').value = updateNode.label;

                                    if (updateNode.font.color === '#FFFFFF') {
                                        document.getElementById('node-font-color').value = "#FFFFFF";
                                    } else {
                                        document.getElementById('node-font-color').value = "#000000";
                                    }

                                    pickr.setColor(updateNode.color);

                                } else if (edge.length != 0) {
                                    vue.showNodeCustomization = false;
                                    vue.showEdgeCustomization = true;

                                    var updateEdge = VIS_EDGES.get(edge)[0];

                                    vue.editEdge = updateEdge;

                                    //Init the label editing
                                    document.getElementById('edge-value').value = updateEdge.label;

                                    //Set the color to what the current node is!
                                    pickr2.setColor(updateEdge.color);

                                    //Init the Alignment
                                    if (updateEdge.font.align === 'top') {
                                        document.getElementById('edge-font-align').value = "top";
                                    } else if (updateEdge.font.align === 'middle') {
                                        document.getElementById('edge-font-align').value = "middle";
                                    } else {
                                        document.getElementById('edge-font-align').value = "bottom";
                                    }
                                }
                            });
                        }
                        else if (newMode == "selectMultiple") {
                            NETWORK.disableEditMode();
                            NETWORK.unselectAll();
                            var currentNodes = NETWORK.getSelectedNodes();
                            var currentEdges = NETWORK.getSelectedEdges();
                            this.showNodeCustomization = true; // temporary
                            this.showEdgeCustomization = true; // temporary
                            NETWORK.on('click', function () {
                                if (NETWORK.getSelectedNodes().length == 0 && NETWORK.getSelectedEdges().length == 0) {
                                    NETWORK.unselectAll();
                                    currentNodes = [];
                                    currentEdges = [];
                                }
                                else if (NETWORK.getSelectedNodes().length != 0) {
                                    selectedNode = NETWORK.getSelectedNodes()[0];
                                    var index = currentNodes.indexOf(String(selectedNode));
                                    if (index != -1) {
                                        currentNodes.splice(index, 1);
                                    }
                                    else {
                                        currentNodes.push(String(NETWORK.getSelectedNodes()));
                                    }
                                    NETWORK.setSelection({ nodes: currentNodes, edges: currentEdges }, { unselectAll: true, highlightEdges: false });
                                }
                                else {
                                    selectedEdge = NETWORK.getSelectedEdges()[0];
                                    var index = currentEdges.indexOf(String(selectedEdge));
                                    if (index != -1) {
                                        currentEdges.splice(index, 1);
                                    }
                                    else {
                                        currentEdges.push(String(NETWORK.getSelectedEdges()));
                                    }
                                    NETWORK.setSelection({ nodes: currentNodes, edges: currentEdges }, { unselectAll: true, highlightEdges: false });
                                }
                            });
                        }
                    }
                },
                pdf: function (event) {

                    let url = window.location.pathname;
                    url = url.split('/');
                    let token = url[url.length - 1];

                    html2canvas(document.getElementById("mynetwork"), {
                        onrendered: function (canvas) {
                            var imgData = canvas.toDataURL('image/png');
                            var doc = new jsPDF('landscape');
                            doc.addImage(imgData, 'PNG', 0, 0);
                            doc.save(token + '.pdf');
                        }
                    });
                },
                img: function (event) {

                    let url = window.location.pathname;
                    url = url.split('/');
                    let token = url[url.length - 1];

                    html2canvas(document.getElementById("mynetwork"), {
                        onrendered: function (canvas) {
                            var imgData = canvas.toDataURL('image/png');
                            app.saveAs(imgData, token + '.png');
                        }
                    });
                },
                saveAs: function (uri, filename) {
                    var link = document.createElement('a');

                    if (typeof link.download === 'string') {

                        link.href = uri;
                        link.download = filename;

                        //Firefox requires the link to be in the body
                        document.body.appendChild(link);

                        //simulate click
                        link.click();

                        //remove the link when done
                        document.body.removeChild(link);

                    } else {

                        window.open(uri);

                    }
                },
                signOut: function (event) {
                    if (this.user) {
                        firebase.auth().signOut().then(function () {
                            // Successfully signed out. This cookie will be set at a early time to expire and delete
                            // ensuring the user is correctly signed out
                            document.cookie = "aff_t=; Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                        }).catch(function (error) {
                            // An error happened.
                        });

                        window.location.href = "/"; // kick thew user to the main page on logout
                    }
                },
                save: function () {
                    console.log(JSON.stringify(SNAPSHOT));
                    var url = window.location.pathname;
                    url = url.split('/');
                    var token = url[url.length - 1];
                    $.ajax({
                        type: 'POST',
                        url: '/api/saveToDB/' + token,
                        contentType: "application/json",
                        data: JSON.stringify(SNAPSHOT),
                        headers: {
                            RequestVerificationToken: $('input:hidden[name="__RequestVerificationToken"]').val()
                        },
                        success: function () {
                            alert('Saved');
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            alert(errorThrown);
                        }
                    });
                }
            }
        });

        const pickr = Pickr.create({
            el: '.color-picker',
            theme: 'nano', // 'classic', 'monolith', or 'nano'

            swatches: [
                'rgba(255, 0, 0, 1)',
                'rgba(255, 127, 0, 1)',
                'rgba(0, 255, 0, 1)',
                'rgba(0, 0, 255, 1)',
                'rgba(75, 0, 130, 1)',
                'rgba(139, 0, 255, 1)',
                'rgba(0, 0, 0, 1)'
            ],

            components: {

                // Main components
                preview: true,
                opacity: true,
                hue: true,

                // Input / output Options
                interaction: {
                    hex: false,
                    rgba: false,
                    hsva: false,
                    input: true,
                    clear: true,
                    save: true
                }
            },

            // Default color
            default: '#000000'
        });

        const pickr2 = Pickr.create({
            el: '.color-picker2',
            theme: 'nano', // 'classic', 'monolith', or 'nano'

            swatches: [
                'rgba(255, 0, 0, 1)',
                'rgba(255, 127, 0, 1)',
                'rgba(0, 255, 0, 1)',
                'rgba(0, 0, 255, 1)',
                'rgba(75, 0, 130, 1)',
                'rgba(139, 0, 255, 1)',
                'rgba(0, 0, 0, 1)'
            ],

            components: {

                // Main components
                preview: true,
                opacity: true,
                hue: true,

                // Input / output Options
                interaction: {
                    hex: false,
                    rgba: false,
                    hsva: false,
                    input: true,
                    clear: true,
                    save: true
                }
            },

            // Default color
            default: '#000000'
        });

        //Saves the new position for the nodes
        NETWORK.on('dragEnd', function (properties) {
            for (var i = 0; i < properties.nodes.length; i++) {
                var nodeId = properties.nodes[i];
                const node = VIS_NODES.get(nodeId);
                repositionNodeAction(nodeId, node.x, node.y, properties.pointer.canvas.x, properties.pointer.canvas.y);
                VIS_NODES.update({ id: nodeId, x: properties.pointer.canvas.x, y: properties.pointer.canvas.y });
            }
        });

        NETWORK.redraw();</script>
}

@{
    ViewData["Title"] = "New Graph";
}

@section styles {
    <style>
        .graph {
            position: relative;
            margin-top: -1rem;
            border: 1px solid rgba(1,1,1,.25);
        }

        .vis-network:focus {
            outline: none;
        }

        #mynetwork {
            border: 1px solid lightgray;
            width: 100%;
            height: 90vh;
            z-index: 1;
            margin: 0 auto;
        }

        .interface {
            position: absolute;
            right: 0;
            z-index: 2;
            background: #BBB;
            width: 25%;
            height: 100%;
            padding: 1rem 0 1rem 1rem;
            margin-bottom: 1rem;
        }

        .button-group {
            position: relative;
        }

        .button-group button {
            font-size: 1rem;
                padding: .5rem 1rem;
                cursor: pointer;
                border: 0;
                margin-bottom: .5rem;
                background: transparent;
                display: inline-block;
         }

                .button-group button:hover {
                    cursor: pointer;
                    color: blue;
                }
        button:focus {
            outline: none;
        }

        .customization-box {
            position: relative;
        }

        .draw-title, .select-title {
            display: inline-block;
            width: 5ch;
            opacity: .25;
            padding-left: 1rem;
            margin-right: 1rem;
        }

        .draw-group button {
            background: transparent;
            font-size: 1rem;
        }

        .status {
            position: absolute;
            bottom: 1rem;
            z-index: 2;
            color: #333;
            opacity: .25;
        }

        .pickr {
            display: inline-block;
        }

        .selectedButton {
            color: #0026ff;
            font-weight: bold;
        }
    </style>
}


    <div class="graph">
        <div class="interface">
            <div class="button-group">
                <div class="draw-group">
                    <span class="draw-title">Draw</span>
                    <button v-on:click="changeMode('drawNodes')" v-bind:class='{ selectedButton: (state == "drawNodes") }'>Nodes</button>
                    <button v-on:click="changeMode('drawEdges')" v-bind:class='{ selectedButton: (state == "drawEdges") }'>Edges</button>
                </div>
                <div class="select-group">
                    <span class="select-title">Select</span>
                    <button v-on:click="changeMode('select')" v-bind:class='{ selectedButton: (state == "select") }'>Single</button>
                    <button v-on:click="changeMode('selectMultiple')" v-bind:class='{ selectedButton: (state == "selectMultiple") }'>Multiple</button>
                </div>
                <button v-if="state == 'select' || state == 'selectMultiple'" v-on:click="deleteSelected()">Delete</button>
                <button v-on:click="undo()">Undo</button>
                <button v-on:click="redo()">Redo</button>
                <button v-on:click="pdf()">Download as Pdf</button>
                <button v-on:click="img()">Download as Png</button>
                <button v-on:click="save()">Save</button>
            </div>
            <div class="customization-box" v-show="showNodeCustomization">
                <h2>Nodes:</h2>
                <label> Label/Weight: <input type="text" id="node-name" /></label>
                <label> Color: <span class="color-picker"></span> </label>
                <br />
                <div class="node-font-colors">
                    <input type="radio" v-on:click="changeNodeFontColor('white')" name="node-font-color" value="white" id="white-node-font" checked />
                    <label for="white">
                        White Font
                    </label>
                    <input type="radio" v-on:click="changeNodeFontColor('black')" name="node-font-color" value="black" id="black-node-font" />
                    <label for="black">
                        Black Font
                    </label>
                </div>
            </div>
            <div class="customization-box" v-show="showEdgeCustomization">
                <h2>Edges:</h2>
                <label> Label/Weight: <input type="text" id="edge-value" /></label>
                <label> Color: <span class="color-picker2"></span> </label>
                <br />
                <div class="edge-font-alignments">
                    <input type="radio" v-on:click="changeEdgeFontAlignment('top')" name="edge-font-alignment" value="top" id="align-top" checked />
                    <label for="top">
                        Top
                    </label>
                    <input type="radio" v-on:click="changeEdgeFontAlignment('middle')" name="edge-font-alignment" value="middle" id="align-middle" />
                    <label for="middle">
                        Middle
                    </label>
                    <input type="radio" v-on:click="changeEdgeFontAlignment('bottom')" name="edge-font-alignment" value="bottom" id="align-bottom" />
                    <label for="bottom">
                        Bottom
                    </label>
                </div>
                <div class="edge-directions">
                    <input type="radio" v-on:click="changeIfDirected('undirected')" name="edge-direction" value="undirected" id="undirected" checked />
                    <label for="undirected">
                        Undirected
                    </label>
                    <input type="radio" v-on:click="changeIfDirected('directed')" name="edge-direction" value="directed" id="directed" />
                    <label for="directed">
                        Directed
                    </label>
                </div>
            </div>
        </div>
        <div class="status">
            <h2 v-if="state=='drawNodes' || state=='drawEdges'">You're drawing {{state=="drawNodes" ? "nodes" : "edges"}}.</h2>
            <h2 v-else>You're in select {{state=="select" ? "" : "multiple"}} mode.</h2>
        </div>
        <div id="mynetwork"></div>
    </div>


@section scripts {
    <!-- The core Firebase JS SDK is always required and must be listed first -->
    <script type="text/javascript" src="https://www.gstatic.com/firebasejs/6.6.2/firebase-app.js"></script>
    <script type="text/javascript" src="https://www.gstatic.com/firebasejs/6.6.1/firebase-auth.js"></script>
    <script type="text/javascript" src="~/js/vis-network.js"></script>
    <script type="text/javascript" src="~/js/FIREBASE_CONFIG.js"></script>
    <script type="text/javascript" src="~/js/firebase.js"></script>
    <script type="text/javascript" src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.4/jspdf.min.js"></script>
    <script type="text/javascript" src="~/js/pickr.min.js"></script>
    <script type="text/javascript">
        const NODES = [];

        const EDGES = [];

        function getGraphData() {
            let url = window.location.pathname;
            url = url.split('/');
            let token = url[url.length - 1];
            $.ajax({
                type: "GET",
                url: "/api/graphData/" + token,
                cache: false,
                async: false,
                success: function (data) {
                    if (data.redirect !== undefined) {
                        window.location.href = data.redirect_url;
                    }
                    
                    var result = jQuery.parseJSON(data);
                    $.each(result, function (key, value) {
                        $.each(value, function (key2, value) {
                            var argb = (value.Color >>> 0).toString(16);
                            var rgba = '#' + argb.slice(2, 9) + argb[0] + argb[1];
                            if (key === "Vertices") {
                                NODES.push({ id: value.ID, x: value.XPos, y: value.YPos, color: rgba, name: value.Name })
                            } else {
                                EDGES.push({ id: value.DBID, first: value.First, second: value.Second, direction: value.Direction, color: rgba, weight: value.Weight })
                            }
                        });
                    });
                }
            });
            return getVisDataSet();
        }
    </script>
    <script>
        // Snapshot Model

        const ACTION_BATCH = "-1"; // A collection of actions
        const ACTION_ADD_VERTEX = "0";
        const ACTION_ADD_EDGE = "1";

        const ACTION_DELETE_VERTEX = "2";
        const ACTION_DELETE_VERTEX_N_EDGE = "3";
        const ACTION_DELETE_EDGE = "4";

        const ACTION_NODE_RECOLOR = "5";
        const ACTION_NODE_RENAME = "6";
        const ACTION_NODE_NAME_RECOLOR = "7";
        const ACTION_NODE_CHANGE_POS = "8";

        const ACTION_EDGE_RENAME = "9";
        const ACTION_EDGE_RECOLOR = "10";
        //TEMPORARY NEEDS TESTING
        const ACTION_EDGE_CHANGE_FONT_ALIGNMENT = "11";
        const ACTION_EDGE_CHANGE_IF_DIRECTED = "12";

        const SNAPSHOT = {
            0: []
        };

        let REDO_STACK = [];
        let CURRENT_SNAPSHOT = 0;

        function clearRedoStack() {
            REDO_STACK = [];
        }

        function startBatchAction() {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_BATCH,
                actions: []
            });
        }

        function moveLastActionToBatch() {
            const lastAction = SNAPSHOT[CURRENT_SNAPSHOT].pop();
            SNAPSHOT[CURRENT_SNAPSHOT][SNAPSHOT[CURRENT_SNAPSHOT].length - 1].actions.push(lastAction);
        }

        function addNodeAction(id_, color_, x_, y_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({ action: ACTION_ADD_VERTEX, id: id_, color: color_, x: x_, y: y_ });
        }

        function addEdgeAction(id_, isDirected_, from_, to_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_ADD_EDGE,
                id: id_,
                isDirected: isDirected_,
                from: from_,
                to: to_
            });
        }

        function deleteNodeAction(node_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_VERTEX,
                node: node_
            });
        }

        function deleteNodeEdgeAction(node_, edges_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_VERTEX_N_EDGE,
                node: node_,
                edges: edges_
            });
        }

        function deleteEdgeAction(edge_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_DELETE_EDGE,
                edge: edge_
            });
        }

        function recolorNodeAction(vertexId, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_RECOLOR,
                id: vertexId,
                prevColor: prevColor_,
                color: color_
            });
        }

        function renameNodeAction(vertexId, fontColor_, prevLabel_, label_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_RENAME,
                id: vertexId,
                fontColor: fontColor_,
                prevLabel: prevLabel_,
                label: label_
            });
        }

        function recolorNodeNameAction(vertexId, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_NAME_RECOLOR,
                id: vertexId,
                prevColor: prevColor_,
                color: color_
            });
        }

        function repositionNodeAction(vertexId, prevX_, prevY_, x_, y_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_NODE_CHANGE_POS,
                id: vertexId,
                prevX: prevX_,
                prevY: prevY_,
                x: x_,
                y: y_

            });
        }

        function renameEdgeAction(id_, from_, to_, alignment_, prevLabel_, label_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_RENAME,
                id: id_,
                from: from_,
                to: to_,
                alignment: alignment_,
                prevLabel: prevLabel_,
                label: label_,
            });
        }

        function recolorEdgeAction(id_, from_, to_, prevColor_, color_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_RECOLOR,
                id: id_,
                from: from_,
                to: to_,
                prevColor: prevColor_,
                color: color_
            });
        }

        function changeEdgeFontAlignmentAction(id_, from_, to_, prevAlignment_, alignment_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_CHANGE_FONT_ALIGNMENT,
                id: id_,
                from: from_,
                to: to_,
                prevAlignment: prevAlignment_,
                alignment: alignment_
            });
        }

        function changeIfEdgeDirectedAction(id_, from_, to_, prevIfDirected_, ifDirected_) {
            SNAPSHOT[CURRENT_SNAPSHOT].push({
                action: ACTION_EDGE_CHANGE_IF_DIRECTED,
                id: id_,
                from: from_,
                prevIfDirected: prevIfDirected_,
                ifDirected: ifDirected_
            });
        }

        function convertHexToDecimal(color) {
            //#XXXXXX (No alpha means = 0xFF => 255 full alpha)
            console.log("Color : " + color);
            var hexString = "";
            if (color.length === 7) {
                hexString = "FF" + color.slice(1, color.length);
            } else { //#XXXXXXXX (Has an alpha value that is between 0-255)
                hexString = color[7] + color[8] + color.slice(1, 7);
            }
            //return the number as a signed integer
            return parseInt(hexString, 16) >> 0;
        }

        function convertDecimalToHex(value) {
            var argb = (value >>> 0).toString(16);
            var rgba = '#' + argb.slice(2, 9) + argb[0] + argb[1];

            return rgba;
        }

        function undoLastAction(state) {
            if (SNAPSHOT[CURRENT_SNAPSHOT].length > 0) {
                const lastAction = SNAPSHOT[CURRENT_SNAPSHOT].pop();

                switch (lastAction.action) {
                    case ACTION_BATCH:
                        for (action of lastAction.actions) {
                            SNAPSHOT[CURRENT_SNAPSHOT].push(action);
                            undoLastAction(state);
                            REDO_STACK.pop(); // Only want the batch action to be stored on REDO_STACK
                        }
                        break;
                    case ACTION_ADD_VERTEX:
                        NETWORK.storePositions();
                        vertex = VIS_NODES.get(lastAction.id);
                        lastAction.x = vertex.x;
                        lastAction.y = vertex.y;
                        VIS_NODES.remove(lastAction.id);
                        break;
                    case ACTION_ADD_EDGE:
                        VIS_EDGES.remove(lastAction.id);
                        break;
                    case ACTION_DELETE_EDGE:
                        VIS_EDGES.add(lastAction.edge);
                        break;
                    case ACTION_DELETE_VERTEX:
                        VIS_NODES.add(lastAction.node);
                        break;
                    case ACTION_DELETE_VERTEX_N_EDGE:
                        VIS_NODES.add(lastAction.node);
                        for (edge of lastAction.edges) {
                            VIS_EDGES.add(edge);
                        }
                        break;
                    case ACTION_NODE_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, color: lastAction.prevColor });
                        break;
                    case ACTION_NODE_RENAME:
                        VIS_NODES.update({ id: lastAction.id, label: lastAction.prevLabel, font: { color: lastAction.fontColor } });
                        break;
                    case ACTION_NODE_NAME_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, font: { color:lastAction.prevColor } });
                        break;
                    case ACTION_NODE_CHANGE_POS:
                        VIS_NODES.update({ id: lastAction.id, x: lastAction.prevX, y: lastAction.prevY });
                        break;
                    case ACTION_EDGE_RENAME:
                        VIS_EDGES.update({ id: lastAction.id, label: lastAction.prevLabel, font: { align: lastAction.alignment } });
                        break;
                    case ACTION_EDGE_RECOLOR:
                        VIS_EDGES.update({ id: lastAction.id, color: lastAction.prevColor });
                        break;
                    case ACTION_EDGE_CHANGE_FONT_ALIGNMENT:
                        VIS_EDGES.update({ id: lastAction.id, font: { align: lastAction.prevAlignment } });
                        break;
                    case ACTION_EDGE_CHANGE_IF_DIRECTED:
                        VIS_EDGES.update({ id: lastAction.id, arrows: { to: lastAction.prevIfDirected } });
                        break;
                }

                REDO_STACK.push(lastAction);
                if (state == "drawNodes") {
                    NETWORK.addNodeMode();
                } else if (state == "drawEdges") {
                    NETWORK.addEdgeMode();
                }
            }
        }

        function redoLastAction(state) {
            if (REDO_STACK.length > 0) {
                const lastAction = REDO_STACK.pop();
                switch (lastAction.action) {
                    case ACTION_BATCH:
                        for (action of lastAction.actions) {
                            REDO_STACK.push(action);
                            redoLastAction(state);
                            SNAPSHOT[CURRENT_SNAPSHOT].pop(); // Don't store individual actions back
                        }
                        SNAPSHOT[CURRENT_SNAPSHOT].push(lastAction);
                        break;
                    case ACTION_ADD_VERTEX:
                        VIS_NODES.add({ id: lastAction.id, label: "", color: lastAction.color, x: lastAction.x, y: lastAction.y });
                        addNodeAction(lastAction.id, lastAction.color, lastAction.x, lastAction.y);
                        break;
                    case ACTION_ADD_EDGE:
                        VIS_EDGES.add({ id: lastAction.id, label: "", arrows: { to: lastAction.isDirected }, from: lastAction.from, to: lastAction.to });
                        addEdgeAction(lastAction.id, lastAction.isDirected, lastAction.from, lastAction.to);
                        break;
                    case ACTION_DELETE_EDGE:
                        VIS_EDGES.remove(lastAction.edge.id);
                        deleteEdgeAction(lastAction.edge);
                        break;
                    case ACTION_DELETE_VERTEX:
                        VIS_NODES.remove(lastAction.node.id);
                        deleteNodeAction(lastAction.node);
                        break;
                    case ACTION_DELETE_VERTEX_N_EDGE:
                        VIS_NODES.remove(lastAction.node.id);
                        for (edge of lastAction.edges) {
                            VIS_EDGES.remove(edge.id);
                        }
                        deleteNodeEdgeAction(lastAction.node, lastAction.edges);
                        break;
                    case ACTION_NODE_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, color: lastAction.color });
                        recolorNodeAction(lastAction.id, lastAction.prevColor, lastAction.color);
                        break;
                    case ACTION_NODE_RENAME:
                        VIS_NODES.update({ id: lastAction.id, label: lastAction.label, font: { color: lastAction.fontColor } });
                        renameNodeAction(lastAction.id, lastAction.fontColor, lastAction.prevLabel, lastAction.label);
                        break;
                    case ACTION_NODE_NAME_RECOLOR:
                        VIS_NODES.update({ id: lastAction.id, font: { color: lastAction.color } });
                        recolorNodeNameAction(lastAction.id, lastAction.prevColor, lastAction.color);
                        break;
                    case ACTION_NODE_CHANGE_POS:
                        VIS_NODES.update({ id: lastAction.id, x: lastAction.x, y: lastAction.y });
                        repositionNodeAction(lastAction.id, lastAction.prevX, lastAction.prevY, lastAction.x, lastAction.y);
                        break;
                    case ACTION_EDGE_RENAME:
                        VIS_EDGES.update({ id: lastAction.id, label: lastAction.label, font: { align: lastAction.alignment } });
                        renameEdgeAction(lastAction.id, lastAction.from, lastAction.to, lastAction.alignment, lastAction.prevLabel, lastAction.label);
                        break;
                    case ACTION_EDGE_RECOLOR:
                        VIS_EDGES.update({ id: lastAction.id, color: lastAction.color });
                        recolorEdgeAction(lastAction.id, lastAction.from, lastAction.to, lastAction.prevColor, lastAction.color);
                        break;
                    case ACTION_EDGE_CHANGE_FONT_ALIGNMENT:
                        VIS_EDGES.update({ id: lastAction.id, font: { align: lastAction.alignment } });
                        changeEdgeFontAlignmentAction(lastAction.id, lastAction.from, lastAction.to, lastAction.prevAlignment, lastAction.alignemnt);
                        break;
                    case ACTION_EDGE_CHANGE_IF_DIRECTED:
                        VIS_EDGES.update({ id: lastAction.id, arrows: { to: lastAction.ifDirected } });
                        changeIfEdgeDirectedAction(lastAction.id, lastAction.from, lastAction.to, lastAction.prevIfDirected, lastAction.ifDirected);
                        break;
                }
                if (state == "drawNodes") {
                    NETWORK.addNodeMode();
                } else if (state == "drawEdges") {
                    NETWORK.addEdgeMode();
                }
            }
        }</script>
    <script type="text/javascript">let NETWORK;
        let VIS_NODES, VIS_EDGES;
        function getVisDataSet() {

            // Convert our DB data to vis data.
            const nodes = [], edges = [];

            for (node of NODES) {
                nodes.push({
                    id: node.id, label: node.name, x: node.x, y: node.y,
                    color: node.color, font: { color: '#FFFFFF' }
                });
            }

            for (edge of EDGES) {
                edges.push({
                    from: edge.first, to: edge.second, color: edge.color,
                    arrows: { to: edge.direction === 2, from: edge.direction === 1, enabled: edge.direction !== 0 },
                    label: edge.weight.toString(), font: { align: 'top' }
                });
            }

            VIS_NODES = new vis.DataSet(nodes);
            VIS_EDGES = new vis.DataSet(edges);

            return {
                nodes: VIS_NODES,
                edges: VIS_EDGES
            };
        }

        var app = new Vue({
            el: '#app',
            data: {
                user: false,
                state: "drawNodes",
                nextNodeID: 0,
                showNodeCustomization: true,
                showEdgeCustomization: false,
                currentNodes: [],
                currentEdges: []
            },
            mounted: function () {
                const options = {
                    autoResize: true,
                    height: "100%",
                    width: "100%",
                    interaction: {
                        hover: true
                    },
                    layout: {
                        randomSeed: undefined
                    },
                    nodes: {
                        physics: false,
                        color: {
                            border: '#2B7CE9',
                            background: '#97C2FC',
                            highlight: {
                                border: '#2B7CE9',
                                background: '#D2E5FF'
                            },
                            hover: {
                                border: '#2B7CE9',
                                background: '#D2E5FF'
                            }
                        },
                        font: {
                            color: '#000000'
                        }
                    },
                    physics: {
                        barnesHut: {
                            gravitationalConstant: 0,
                            centralGravity: 0,
                            springConstant: 0,
                        }
                    },
                    edges: {
                        smooth: false
                    },
                    manipulation: {
                        enabled: true,
                        addNode: function (data, callback) {
                            data.id = nextNodeID;
                            data.color = pickr.getColor().toHEXA().toString();
                            VIS_NODES.update({ id: data.id, label: "", color: data.color, font: { color: '#FFFFFF' }, x: data.x, y: data.y });
                            nextNodeID++;
                            callback(data);
                            addNodeAction(data.id, data.color, data.x, data.y);
                            clearRedoStack();
                            NETWORK.addNodeMode();
                            var addedNodeID = [data.id];
                            NETWORK.selectNodes(addedNodeID, false);
                            document.getElementById('node-name').value = "";
                            document.getElementById('node-name').focus();
                        },
                        addEdge: function (data, callback) {
                            data.color = pickr2.getColor().toHEXA().toString();
                            if (data.from == data.to && this.state == "drawEdges") {
                                if (confirm("Do you want to connect the node to itself?")) {
                                    callback(data);
                                   // addEdgeAction(data.id, data.from, data.to);
                                }
                            }
                            else {
                                callback(data);
                                //addEdgeAction(data.id, data.from, data.to);
                            }
                            clearRedoStack();

                            var directed = false;
                            if (document.querySelector('input[name="edge-direction"]:checked').value == "directed") {
                                directed = true;
                            }

                            addEdgeAction(data.id, directed, data.from, data.to);
                            VIS_EDGES.update({ id: data.id, label: "", color: data.color, font: { color: '#000000' }, arrows: { to: directed }, from: data.from, to: data.to });

                            NETWORK.addEdgeMode();

                            var addedEdgeID = [data.id];
                            NETWORK.selectEdges(addedEdgeID);
                            document.getElementById('edge-value').value = "";
                            document.getElementById('edge-value').focus();
                        },
                        deleteNode: function (data, callback) {
                            const nodeId = data.nodes[0];
                            const node = VIS_NODES.get(nodeId);
                            const connectedEdges = NETWORK.getConnectedEdges(nodeId);
                            if (connectedEdges.length > 0) {
                                var edges = [];
                                for (edgeId of connectedEdges) {
                                    edges.push(VIS_EDGES.get(edgeId));
                                    VIS_EDGES.remove(edgeId);
                                }
                                VIS_NODES.remove(nodeId);
                                deleteNodeEdgeAction(node, edges);
                            }
                            else {
                                VIS_NODES.remove(nodeId);
                                deleteNodeAction(node);
                            }
                            clearRedoStack();
                            callback(data);
                        },
                        deleteEdge: function (data, callback) {
                            const edge = VIS_EDGES.get(data.edges[0]) || false;
                            if (edge) {
                                deleteEdgeAction(edge);
                                VIS_EDGES.remove(edge.id);
                                clearRedoStack();
                                callback(data);
                            }
                        }
                    }
                };

                let url = window.location.pathname;
                url = url.split('/');
                let token = url[url.length - 1];

                let vue = this;

                $.ajax({
                    type: 'GET',
                    url: "/api/getStartingNodeID/" + token,
                    cache: false,
                    async: false,
                    success: function (data) {
                        vue.nextNodeID = data;
                    }
                });

                NETWORK = new vis.Network(document.getElementById('mynetwork'), getGraphData(), options);
                nextNodeID = VIS_NODES.length;
                NETWORK.addNodeMode();
            },
            created: function () {
                // When user logs in, store it in this Vue app's data.
                // Add cookie storing user token.
                firebase.auth().onAuthStateChanged(user => {
                    if (user) {
                        this.user = user;
                        user.getIdToken().then(function (idToken) {
                            document.cookie = "aff_t=" + idToken;
                        });
                    }
                    // Reset user
                    else {
                        this.user = user;
                        document.cookie = "aff_t=; Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                    }
                });
            },
            methods: {
                undo: function (event) {
                    undoLastAction(this.state);
                },
                redo: function (event) {
                    redoLastAction(this.state);
                },
                deleteSelected: function (event) {
                    const nodes_ = NETWORK.getSelectedNodes();
                    let edges_ = NETWORK.getSelectedEdges();

                    let isBatchAction = false;
                    if (nodes_.length > 1 || edges_.length > 1) {
                        isBatchAction = true;
                    } else if (nodes_.length > 0 && edges_.length > 0) {
                        isBatchAction = true;
                    }

                    if (isBatchAction) {
                        startBatchAction();
                    }

                    for (node of nodes_) {
                        NETWORK.manipulation.options.deleteNode({
                            nodes: [node]
                        }, (d) => { });
                        if (isBatchAction) moveLastActionToBatch();
                    }

                    // Reselect edges, in case they were deleted by node deletion
                    edges_ = NETWORK.getSelectedEdges();

                    for (edge of edges_) {
                        NETWORK.manipulation.options.deleteEdge({
                            edges: [edge]
                        }, (d) => { });
                        if (isBatchAction) moveLastActionToBatch(); 
                    }

                    clearRedoStack();
                    NETWORK.disableEditMode();

                    this.currentNodes = [];
                    this.currentEdges = [];
                },
                save: function () {
                    console.log(JSON.stringify(SNAPSHOT));
                    var url = window.location.pathname;
                    url = url.split('/');
                    var token = url[url.length - 1];
                    $.ajax({
                        type: 'POST',
                        url: '/api/saveToDB/' + token,
                        contentType: "application/json",
                        data: JSON.stringify(SNAPSHOT),
                        headers: {
                            RequestVerificationToken: $('input:hidden[name="__RequestVerificationToken"]').val()
                        },
                        success: function () {
                            alert('Saved');
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            alert(errorThrown);
                        }
                    });
                },
                changeMode: function (newMode) {
                    if (this.state == newMode) {
                        //clicked on same button, exit mode or do nothing?
                    }
                    else {
                        NETWORK.unselectAll();
                        if (this.state == "select" || this.state == "selectMultiple") {
                            NETWORK.off('click');
                        }
                        this.state = newMode;
                        if (newMode == "drawNodes") {
                            this.showNodeCustomization = true;
                            this.showEdgeCustomization = false;
                            NETWORK.addNodeMode();
                        }
                        else if (newMode == "drawEdges") {
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = true;
                            NETWORK.addEdgeMode();
                        }
                        else if (newMode == "select") {
                            NETWORK.disableEditMode();
                            this.showNodeCustomization = false;
                            this.showEdgeCustomization = false;
                            var vue = this;
                            NETWORK.on('click', function (properties) {
                                if (NETWORK.getSelectedNodes().length != 0) {
                                    NETWORK.selectNodes(NETWORK.getSelectedNodes(), false);
                                }

                                //Get the node that we have clicked on
                                var node = properties.nodes;
                                //Get the edge that we have clicked on
                                var edge = properties.edges;

                                //If we hit a node else we hit an edge or nothing
                                if (node.length != 0) {
                                    vue.showNodeCustomization = true;
                                    vue.showEdgeCustomization = false;

                                    var updateNode = VIS_NODES.get(node)[0];

                                    document.getElementById('node-name').value = updateNode.label;

                                    document.getElementById('node-name').focus();

                                    //if (updateNode.font.color === '#FFFFFF') {
                                    //    document.getElementById('node-font-color').value = "#FFFFFF";
                                    //} else {
                                    //    document.getElementById('node-font-color').value = "#000000";
                                    //}

                                    pickr.setColor(updateNode.color);

                                } else if (edge.length != 0) {
                                    vue.showNodeCustomization = false;
                                    vue.showEdgeCustomization = true;

                                    var updateEdge = VIS_EDGES.get(edge)[0];

                                    //Init the label editing
                                    document.getElementById('edge-value').value = updateEdge.label;

                                    document.getElementById('edge-value').focus();

                                    //Set the color to what the current node is!
                                    pickr2.setColor(updateEdge.color);

                                    //Init the Alignment
                                    //if (updateEdge.font.align === 'top') {
                                    //    document.getElementById('edge-font-align').value = "top";
                                    //} else if (updateEdge.font.align === 'middle') {
                                    //    document.getElementById('edge-font-align').value = "middle";
                                    //} else {
                                    //    document.getElementById('edge-font-align').value = "bottom";
                                    //}
                                }
                            });
                        }
                        else if (newMode == "selectMultiple") {
                            NETWORK.disableEditMode();
                            NETWORK.unselectAll();
                            this.currentNodes = NETWORK.getSelectedNodes();
                            this.currentEdges = NETWORK.getSelectedEdges();
                            this.showNodeCustomization = true; // temporary
                            this.showEdgeCustomization = true; // temporary

                            var vue = this;
                            NETWORK.on('click', function () {
                                if (NETWORK.getSelectedNodes().length == 0 && NETWORK.getSelectedEdges().length == 0) {
                                    NETWORK.unselectAll();
                                    vue.currentNodes = [];
                                    vue.currentEdges = [];
                                }
                                else if (NETWORK.getSelectedNodes().length != 0) {
                                    selectedNode = NETWORK.getSelectedNodes()[0];
                                    var index = vue.currentNodes.indexOf(String(selectedNode));
                                    if (index != -1) {
                                        vue.currentNodes.splice(index, 1);
                                    }
                                    else {
                                        vue.currentNodes.push(String(NETWORK.getSelectedNodes()));
                                    }
                                    NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                }
                                else {
                                    selectedEdge = NETWORK.getSelectedEdges()[0];
                                    var index = vue.currentEdges.indexOf(String(selectedEdge));
                                    if (index != -1) {
                                        vue.currentEdges.splice(index, 1);
                                    }
                                    else {
                                        vue.currentEdges.push(String(NETWORK.getSelectedEdges()));
                                    }
                                    NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                }
                            });

                            NETWORK.on('dragEnd', function () {
                                if (NETWORK.getSelectedNodes().length == 1) {
                                    if (vue.currentNodes.length != 1) {
                                        vue.currentNodes = [];
                                        vue.currentEdges = [];
                                        vue.currentNodes.push(String(NETWORK.getSelectedNodes()));
                                        NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                    }
                                    else if (vue.currentNodes.length == 1) {
                                        if (String(NETWORK.getSelectedNodes()[0]) != vue.currentNodes[0]) {
                                            vue.currentNodes = [];
                                            vue.currentEdges = [];
                                            vue.currentNodes.push(String(NETWORK.getSelectedNodes()));
                                            NETWORK.setSelection({ nodes: vue.currentNodes, edges: vue.currentEdges }, { unselectAll: true, highlightEdges: false });
                                        }
                                    }
                                }            
                            });
                        }
                    }
                },
                changeNodeFontColor: function (newFontColor) {
                    if (newFontColor == "white") {
                        newFontColor = "#FFFFFF";
                    }
                    else if(newFontColor == "black") {
                        newFontColor = "#000000";
                    }

                    var editNodeIDS = NETWORK.getSelectedNodes();
                    editNodeIDS.forEach(id => {
                        var editNode = VIS_NODES.get(id);

                        if (editNode.font.color !== newFontColor) {
                            recolorNodeNameAction(editNode.id, editNode.font.color, newFontColor);
                            clearRedoStack();
                            editNode.font.color = newFontColor;     
                        }

                        VIS_NODES.update(editNode);
                    });
                },
                changeEdgeFontAlignment: function (newAlignment) {
                    var editEdgeIDS = NETWORK.getSelectedEdges();
                    editEdgeIDS.forEach(id => {
                        var editEdge = VIS_EDGES.get(id);

                        if (editEdge.font.align != newAlignment) {
                            changeEdgeFontAlignmentAction(editEdge.id, editEdge.from, editEdge.to, editEdge.font.align, newAlignment);//TEST
                            clearRedoStack();
                            editEdge.font.align = newAlignment;
                        }
                       
                        VIS_EDGES.update(editEdge);
                    });
                },
                changeIfDirected: function (newState) {
                    var directed = false;
                    if (newState == 'directed') {
                        directed = true;
                    }
                    var editEdgeIDS = NETWORK.getSelectedEdges();
                    editEdgeIDS.forEach(id => {
                        var editEdge = VIS_EDGES.get(id);

                        if (editEdge.arrows.to != directed) {
                            changeIfEdgeDirectedAction(editEdge.id, editEdge.from, editEdge.to, editEdge.arrows.to, directed);
                            clearRedoStack();
                            editEdge.arrows.to = directed;
                        }

                        VIS_EDGES.update(editEdge);
                    });
                },
                pdf: function (event) {

                    let url = window.location.pathname;
                    url = url.split('/');
                    let token = url[url.length - 1];

                    html2canvas(document.getElementById("mynetwork"), {
                        onrendered: function (canvas) {
                            var imgData = canvas.toDataURL('image/png');
                            var doc = new jsPDF('landscape');
                            doc.addImage(imgData, 'PNG', 0, 0);
                            doc.save(token + '.pdf');
                        }
                    });
                },
                img: function (event) {

                    let url = window.location.pathname;
                    url = url.split('/');
                    let token = url[url.length - 1];

                    html2canvas(document.getElementById("mynetwork"), {
                        onrendered: function (canvas) {
                            var imgData = canvas.toDataURL('image/png');
                            app.saveAs(imgData, token + '.png');
                        }
                    });
                },
                saveAs: function (uri, filename) {
                    var link = document.createElement('a');

                    if (typeof link.download === 'string') {

                        link.href = uri;
                        link.download = filename;

                        //Firefox requires the link to be in the body
                        document.body.appendChild(link);

                        //simulate click
                        link.click();

                        //remove the link when done
                        document.body.removeChild(link);

                    } else {

                        window.open(uri);

                    }
                },
                signOut: function (event) {
                    if (this.user) {
                        firebase.auth().signOut().then(function () {
                            // Successfully signed out. This cookie will be set at a early time to expire and delete
                            // ensuring the user is correctly signed out
                            document.cookie = "aff_t=; Thu, 01 Jan 1970 00:00:00 UTC; path=/;";
                        }).catch(function (error) {
                            // An error happened.
                        });

                        window.location.href = "/"; // kick thew user to the main page on logout
                    }
                },
                save: function () {
                    console.log(JSON.stringify(SNAPSHOT));
                    var url = window.location.pathname;
                    url = url.split('/');
                    var token = url[url.length - 1];
                    $.ajax({
                        type: 'POST',
                        url: '/api/saveToDB/' + token,
                        contentType: "application/json",
                        data: JSON.stringify(SNAPSHOT),
                        headers: {
                            RequestVerificationToken: $('input:hidden[name="__RequestVerificationToken"]').val()
                        },
                        success: function () {
                            alert('Saved');
                        },
                        error: function (xhr, textStatus, errorThrown) {
                            alert(errorThrown);
                        }
                    });
                }
            }
        });

        const pickr = Pickr.create({
            el: '.color-picker',
            theme: 'nano', // 'classic', 'monolith', or 'nano'

            swatches: [
                'rgba(255, 0, 0, 1)',
                'rgba(255, 127, 0, 1)',
                'rgba(0, 255, 0, 1)',
                'rgba(0, 0, 255, 1)',
                'rgba(75, 0, 130, 1)',
                'rgba(139, 0, 255, 1)',
                'rgba(0, 0, 0, 1)'
            ],

            components: {

                // Main components
                preview: true,
                opacity: true,
                hue: true,

                // Input / output Options
                interaction: {
                    hex: false,
                    rgba: false,
                    hsva: false,
                    input: true,
                    clear: true,
                    save: true
                }
            },

            // Default color
            default: '#000000'
        });

        const pickr2 = Pickr.create({
            el: '.color-picker2',
            theme: 'nano', // 'classic', 'monolith', or 'nano'

            swatches: [
                'rgba(255, 0, 0, 1)',
                'rgba(255, 127, 0, 1)',
                'rgba(0, 255, 0, 1)',
                'rgba(0, 0, 255, 1)',
                'rgba(75, 0, 130, 1)',
                'rgba(139, 0, 255, 1)',
                'rgba(0, 0, 0, 1)'
            ],

            components: {

                // Main components
                preview: true,
                opacity: true,
                hue: true,

                // Input / output Options
                interaction: {
                    hex: false,
                    rgba: false,
                    hsva: false,
                    input: true,
                    clear: true,
                    save: true
                }
            },

            // Default color
            default: '#000000'
        });

        pickr.on('save', (color, instance) => {
            pickr.hide();
            if (color != null) {
                color = color.toHEXA().toString();
                var editNodeIDS = NETWORK.getSelectedNodes();
                editNodeIDS.forEach(id => {
                    var editNode = VIS_NODES.get(id);

                    if (editNode.color !== color) {
                        recolorNodeAction(editNode.id, editNode.color, color);
                        clearRedoStack();
                        editNode.color = color;
                    }

                    VIS_NODES.update(editNode);
                });

                var editEdgeIDS = NETWORK.getSelectedEdges();
                editEdgeIDS.forEach(id => {
                    var editEdge = VIS_EDGES.get(id);

                    if (editEdge.color !== color) {
                        recolorEdgeAction(editEdge.id, editEdge.from, editEdge.to, editEdge.color, color);
                        clearRedoStack();
                        editEdge.color = color;
                    }
                    
                    VIS_EDGES.update(editEdge);
                });

            }
        });

        document.getElementById('node-name').addEventListener("keyup", function (event) {
            if (event.key == "Enter") {
                var newLabel = document.getElementById('node-name').value;

                var editNodeIDS = NETWORK.getSelectedNodes();
                editNodeIDS.forEach(id => {
                    var editNode = VIS_NODES.get(id);

                    if (editNode.label !== newLabel) {
                        editNode.font.color = document.querySelector('input[name="node-font-color"]:checked').value;
                        renameNodeAction(editNode.id, editNode.font.color, editNode.label, newLabel);
                        clearRedoStack();
                        editNode.label = newLabel;
                    }

                    VIS_NODES.update(editNode);
                });
            }
        });

        document.getElementById('edge-value').addEventListener("keyup", function (event) {
            if (event.key == "Enter") {
                var newLabel = document.getElementById('edge-value').value;

                var editEdgeIDS = NETWORK.getSelectedEdges();
                editEdgeIDS.forEach(id => {
                    var editEdge = VIS_EDGES.get(id);

                    var newLabel = document.getElementById('edge-value').value;

                    if (editEdge.label !== newLabel) {
                        editEdge.font.align = document.querySelector('input[name="edge-font-alignment"]:checked').value;
                        renameEdgeAction(editEdge.id, editEdge.from, editEdge.to, editEdge.font.align, editEdge.label, newLabel);
                        clearRedoStack();
                        editEdge.label = newLabel;

                    }

                    VIS_EDGES.update(editEdge);
                });
            }
        });

        var startX, startY;
        //Saves the new position for the nodes
        NETWORK.on('dragStart', function (properties) {
            startX = properties.pointer.canvas.x;
            startY = properties.pointer.canvas.y;
        });

        NETWORK.on('dragEnd', function (properties) {
            var xDifference = properties.pointer.canvas.x - startX;
            var yDifference = properties.pointer.canvas.y - startY;

            var selectedNodes = NETWORK.getSelectedNodes();
            for (var i = 0; i < selectedNodes.length; i++) {
                var nodeId = selectedNodes[i];
                const node = VIS_NODES.get(nodeId);
                repositionNodeAction(nodeId, node.x, node.y, (node.x + xDifference), (node.y + yDifference));
                clearRedoStack();
                VIS_NODES.update({ id: nodeId, x: (node.x + xDifference), y: (node.y + yDifference) });
            }   
        });
        
        NETWORK.fit();
        NETWORK.redraw();</script>
}
